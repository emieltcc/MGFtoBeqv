(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(**************************************************************************************************************************)
(* This is the modular graph forms package which facilitates computations with dihedral and trihedral modular graph forms. *)
(* Jan E. Gerken                                                                                                                *)
(* July 2020                                                                                                                     *)
(**************************************************************************************************************************)


BeginPackage["ModularGraphForms`"]
Unprotect["ModularGraphForms`*"];


tau::usage="Modular parameter";
tauBar::usage="Complex conjugate of the modular parameter \[Tau]";
y::usage="Shorthand for \[Pi] \!\(\*SubscriptBox[\(\[Tau]\), \(2\)]\)";
zeta::usage="Multiple zeta values";
bCoeff::usage="Coefficient in the basis expanison used in the sieve algorithm.";


c::usage = "With one argument: dihedral MGF, with three arguments: trihedral MGF, with six arguments: tetrahedral MGF";
a::usage = "Like c, but a MGF minus its complex conjugate";

g::usage = "Holomorphic Eisenstein series";
gHat::usage = "Modular but non-holomorphic version of weight-2 holomorphic Eisenstein series";
gBar::usage="Antiholomorphic Eisenstein series";
gBarHat::usage="Modular but non-antiholomorphic version of weight-2 antiholomorphic Eisenstein series";

e::usage="(Generalized) non-holomorphic Eisenstein series \!\(\*SubscriptBox[\(E\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";
ep::usage="Primed generalized non-holomorphic Eisenstein series E\!\(\*SubscriptBox[\('\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";
b::usage="Basis element \!\(\*SubscriptBox[\(B\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\) for modular graph functions";
bp::usage="Basis element B\!\(\*SubscriptBox[\('\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\) for modular graph functions";

nablaE::usage="Holomorphic Cauchy-Riemann derivatives of generalized non-holomorphic Eisenstein series, \!\(\*SuperscriptBox[\(\[Del]\), \(r\)]\)\!\(\*SubscriptBox[\(E\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";
nablaBarE::usage="Antiholomorphic Cauchy-Riemann derivatives of generalized non-holomorphic Eisenstein series, \!\(\*SuperscriptBox[OverscriptBox[\(\[Del]\), \(_\)], \(r\)]\)\!\(\*SubscriptBox[\(E\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";
nablaEp::usage="Holomorphic Cauchy-Riemann derivatives of primed generalized non-holomorphic Eisenstein series, \!\(\*SuperscriptBox[\(\[Del]\), \(r\)]\)E\!\(\*SubscriptBox[\('\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";
nablaBarEp::usage="Antiholomorphic Cauchy-Riemann derivatives of primed generalized non-holomorphic Eisenstein series, \!\(\*SuperscriptBox[OverscriptBox[\(\[Del]\), \(_\)], \(r\)]\)E\!\(\*SubscriptBox[\('\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";
nablaB::usage="Holomorphic Cauchy-Riemann derivatives of basis element \!\(\*SubscriptBox[\(B\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\), \!\(\*SuperscriptBox[\(\[Del]\), \(r\)]\)\!\(\*SubscriptBox[\(B\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";
nablaBarBBar::usage="Complex conjugate of holomorphic Cauchy-Riemann derivatives of basis element \!\(\*SubscriptBox[\(B\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\), \!\(\*SuperscriptBox[OverscriptBox[\(\[Del]\), \(_\)], \(r\)]\)\!\(\*SubscriptBox[OverscriptBox[\(B\), \(_\)], \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";
nablaBp::usage="Holomorphic Cauchy-Riemann derivatives of basis element B\!\(\*SubscriptBox[\('\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\), \!\(\*SuperscriptBox[\(\[Del]\), \(r\)]\)B\!\(\*SubscriptBox[\('\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";
nablaBarBpBar::usage="Complex conjugate of holomorphic Cauchy-Riemann derivatives of basis element B\!\(\*SubscriptBox[\('\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\), \!\(\*SuperscriptBox[OverscriptBox[\(\[Del]\), \(_\)], \(r\)]\)\!\(\*OverscriptBox[\(B\), \(_\)]\)\!\(\*SubscriptBox[\('\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\)";

intConst::usage="Unknown integration constant";
intConstBar::usage="Complex conjugate of an unknown integration constant";


esv::usage="Iterated Eisenstein integrals \!\(\*SuperscriptBox[\(\[ScriptCapitalE]\), \(sv\)]\)[\!\(\*TagBox[GridBox[{
{\(\*SubscriptBox[\(j\), \(1\)] .  .  .  \*SubscriptBox[\(j\), \(\[ScriptL]\)]\)},
{\(\*SubscriptBox[\(k\), \(1\)] .  .  .  \*SubscriptBox[\(k\), \(\[ScriptL]\)]\)}
}],
DisplayForm]\)]";
esvS::usage="Modular S-transformed iterated Eisenstein integrals \!\(\*SuperscriptBox[\(\[ScriptCapitalE]\), \(sv\)]\)[\!\(\*TagBox[GridBox[{
{\(\*SubscriptBox[\(j\), \(1\)] .  .  .  \*SubscriptBox[\(j\), \(\[ScriptL]\)]\)},
{\(\*SubscriptBox[\(k\), \(1\)] .  .  .  \*SubscriptBox[\(k\), \(\[ScriptL]\)]\)}
}],
DisplayForm]\)]";
esvBar::usage="Complex conjugated iterated Eisenstein integrals \!\(\*SuperscriptBox[\(\[ScriptCapitalE]\), \(sv\)]\)[\!\(\*TagBox[GridBox[{
{\(\*SubscriptBox[\(j\), \(1\)] .  .  .  \*SubscriptBox[\(j\), \(\[ScriptL]\)]\)},
{\(\*SubscriptBox[\(k\), \(1\)] .  .  .  \*SubscriptBox[\(k\), \(\[ScriptL]\)]\)}
}],
DisplayForm]\)]";
betasv::usage="Iterated Eisenstein integrals \!\(\*SuperscriptBox[\(\[Beta]\), \(sv\)]\)[\!\(\*TagBox[GridBox[{
{\(\*SubscriptBox[\(j\), \(1\)] .  .  .  \*SubscriptBox[\(j\), \(\[ScriptL]\)]\)},
{\(\*SubscriptBox[\(k\), \(1\)] .  .  .  \*SubscriptBox[\(k\), \(\[ScriptL]\)]\)}
}],
DisplayForm]\)]";
betasvBar::usage="Complex conjugated iterated Eisenstein integrals \!\(\*SuperscriptBox[\(\[Beta]\), \(sv\)]\)[\!\(\*TagBox[GridBox[{
{\(\*SubscriptBox[\(j\), \(1\)] .  .  .  \*SubscriptBox[\(j\), \(\[ScriptL]\)]\)},
{\(\*SubscriptBox[\(k\), \(1\)] .  .  .  \*SubscriptBox[\(k\), \(\[ScriptL]\)]\)}
}],
DisplayForm]\)]";
betasvS::usage="Modular S-transformed iterated Eisenstein integrals \!\(\*SuperscriptBox[\(\[Beta]\), \(sv\)]\)[\!\(\*TagBox[GridBox[{
{\(\*SubscriptBox[\(j\), \(1\)] .  .  .  \*SubscriptBox[\(j\), \(\[ScriptL]\)]\)},
{\(\*SubscriptBox[\(k\), \(1\)] .  .  .  \*SubscriptBox[\(k\), \(\[ScriptL]\)]\)}
}],
DisplayForm]\)]";


eta::usage="Holomorphic expansion variable in the generating series of Koba-Nielsen integrals";
etaBar::usage="Anitholomorphic expansion variable in the generating series of Koba-Nielsen integrals";
s::usage="Mandelstam variables";

fz::usage="Function \!\(\*SubscriptBox[SuperscriptBox[\(f\), \((a)\)], \(ij\)]\) appering in a Koba\[LongDash]Nielsen integral.";
fBarz::usage="Function \!\(\*SubscriptBox[SuperscriptBox[OverscriptBox[\(f\), \(_\)], \((b)\)], \(ij\)]\) appering in a Koba\[LongDash]Nielsen integral.";
vz::usage="Function \!\(\*SubscriptBox[\(V\), \(a\)]\)(1,2,...,n) appering in a Koba\[LongDash]Nielsen integral.";
vBarz::usage="Function \!\(\*SubscriptBox[OverscriptBox[\(V\), \(_\)], \(b\)]\)(1,2,...,n) appering in a Koba\[LongDash]Nielsen integral.";
gz::usage="Green function \!\(\*SubscriptBox[\(G\), \(\(ij\)\(\\\ \)\)]\)appering in a Koba\[LongDash]Nielsen integral.";
cz::usage="Function \!\(\*SubscriptBox[SuperscriptBox[\(C\), \((a, b)\)], \(ij\)]\) appearing in a Koba\[LongDash]Nielsen integral.";

zIntegrate::usage="Evaluates a Koba\[LongDash]Nielsen integral in terms of modular graph forms at a certain order in the Mandelstam variables. The first argument is the z-dependent integrant in front of the Koba\[LongDash]Nielsen factor, the second argument is the number of points in the Koba\[LongDash]Nielsen factor (an integer) or the list of point-pairs appearing in the Koba\[LongDash]Nielsen factor. The third argument is the order in Mandelstams to be evaluated.";


CSort::usage="Expects a combination of c[] functions and sorts the columns to canonical order.";

CCheckConv::usage="Expects a combination c[] and checks the dihedral and trihedral MGF and Eisenstein series for abosulte convergence and returns true or false.";
CComplexConj::usage="Complex conjugate a combination of c[]";

CHolCR::usage="Expects a combination of c[] and preforms the holomorphic Cauchy-Riemann derivative (2\!\(\*SubscriptBox[\(\[ImaginaryI]\[Tau]\), \(2\)]\)\!\(\*SubscriptBox[\(\[PartialD]\), \(\[Tau]\)]\)+a) if the expression has holomorphic modular weight a.";
CAHolCR::usage="Expects a combination of c[] and preforms the antiholomorphic Cauchy-Riemann derivative (-2\!\(\*SubscriptBox[\(\[ImaginaryI]\[Tau]\), \(2\)]\)\!\(\*SubscriptBox[\(\[PartialD]\), OverscriptBox[\(\[Tau]\), \(_\)]]\)+b) if the expression has anitholomorphic modular weight b.";
divDer::usage="Option for CHolCR and CAHolCR which specifies if dervatives of divergent graphs are computed or not. Possible values are True and False.";

CSimplify::usage ="Expects as argument an expression involving dihedral and trihedral c-functions and tries to perform as many simplifications as possible.";
useIds::usage="Option for simplification functions which specifies if the identity data mine is used. Possible values are True and False.";
divHSR::usage="Option for simplification functions which specifies if divergent HSR is performed. Note that this can be switched on and off for dihedral and trihedral graphs separately using the options diDivHSR and triDivHSR. Possible values are True and False.";
momSimplify::usage="Option for simplification functions which specifies if entries of -1 are removed via momentum conservation or not. Possible values are True and False.";

CConvertToNablaE::usage="Convert basis elements of MGF to \!\(\*SubscriptBox[\(E\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\) and \!\(\*SubscriptBox[\(B\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\), their Cauchy-Riemann derivatives and complex conjugates.";

CConvertFromNablaE::usage="Convert basis elements of MGF from \!\(\*SubscriptBox[\(E\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\) and \!\(\*SubscriptBox[\(B\), \(\(\*SubscriptBox[\(k\), \(1\)] ... \) \*SubscriptBox[\(k\), \(n\)]\)]\), their Cauchy-Riemann derivatives and complex conjugates into C-functions";

CLaurentPoly::usage="Replaces MGF by their Laurent polynomial if known";
usey::usage="Option for CToItInt and CLaurentPoly which specifies if instead of \!\(\*SubscriptBox[\(\[Tau]\), \(\(2\)\(,\)\)]\) y=\!\(\*SubscriptBox[\(\[Pi]\[Tau]\), \(2\)]\) is used in the output. Possible values are True and False.";

CListHSRs::usage="List all dihedral and trihedral MGFs in the argument which contain a closed holomorphic subgraph";

CModWeight::usage="Returns the modular weight of the argument and generates a warning that the argument does not have homogeneous modular weight";

CBasis::usage="Returns the basis of MGFs of given weight.";
basis::usage="Option for CBasis which specifies the basis to be returned. Possible values are \"C\" and \"nablaE\". Also used as an option for CSieveDecomp to specify which basis to decompose into. Value should be a list of basis elements of the same modular weight as the MGF to be decomposed. If set to an empty list, use CBasis to determine the basis automatically.";

CSieveDecomp::usage="Use the sieve algorithm to decompose an MGF. Arguments are the MGF and a list of MGFs that are the basis in which to expand. If no or an empty list is given, use basis which is also used for the datamine.";
CSimplifyOpts::usage="Option for CSieveDecomp which specifies the arguments for CSimplify used after each derivative step. Should be a list of option rules for CSimplify.";
verbose::usage="Option for CSieveDecomp which specifies if verbose output to debug a problem should be printed in very step or not. Possible values are True and False.";
addIds::usage="Option for CSieveDecomp which specifies a list of additional identities which are used to simplify the derivatives.";


DiHolMomConsId::usage ="Expects a dihedral MGF as as seed and generates the holomorphic momentum conservation identity which follows from this.";
DiAHolMomConsId::usage ="Expects a dihedral MGF as as seed and generates the antiholomorphic momentum conservation identity which follows from this.";

DiCSimplify::usage="Expects a combination of c[] and performs all known dihedral simplifications, including holomorphic subgraph reduction and explicitly implemented identities until no more dihedral simplifications can be performed. Does not touch trihedral or tetrahedral modular graph forms.";
diHSR::usage="Option for simplification functions which specifies if any dihedral HSR is performed or not. Possible values are True and False.";
diDivHSR::usage="Option for (dihedral) simplification functions which specifies if divergent HSR is performed in dihedral graphs. Possible values are True and False.";
basisExpandG::usage="Option for (dihedral) simplification functions which specifies if holomorphic Eisenstein series are expanded in the basis of products of powers of \!\(\*SubscriptBox[\(G\), \(4\)]\) and \!\(\*SubscriptBox[\(G\), \(6\)]\) and if Ramanujan identities are used to simplify derivatives of holomorphic Eisenstein series. Possible values are True and False.";
repGHat2::usage="Option for (dihedral) simplification functions which specifies if c[\*GridBox[{
{2, 0},
{0, 0}
}]] is replaced by gHat[2] or not. Possible values are True and False.";


TriHolMomConsId::usage ="Expects a trihedral MGF as as seed and a list containing the numbers of two of the three blocks and generates the holomorphic momentum conservation identity which follows from this.";
TriAHolMomConsId::usage ="Expects a trihedral MGF as as seed and a list containing the numbers of two of the three blocks and generates the antiholomorphic momentum conservation identity which follows from this.";

TriFay::usage="Generate Fay identity for trihedral MGF given in the first argument. If no second argument is provided, the first suitable pair of columns is selected. If a second argument of the form {{block1,col1},{block2,col2}} is provided, these columns are used.";

TriCSimplify::usage="Expects a combination of c[] and performs all known trihedral simplifications, including two- and three-point holomorphic subgraph reduction and explicitly implemented identities until no more trihedral simplifications can be performed. Does not touch dihedral or tetrahedral modular graph forms.";
triHSR::usage="Option for simplification functions which specifies if any trihedral HSR is performed or not. Possible values are True and False.";
tri2ptHSR::usage="Option for simplification functions which specifies if 2pt trihedral HSR is performed or not. Possible values are True and False.";
tri3ptHSR::usage="Option for simplification functions which specifies if 3pt trihedral HSR is performed or not. Possible values are True and False.";
tri3ptFayHSR::usage="Option for simplification functions which specifies if 3pt trihedral HSR is performed using Fay identities instead of Eisenstein-summed lattice sums. Possible values are True and False.";
triDivHSR::usage="Option for (trihedral) simplification functions which specifies if divergent HSR is performed in trihedral graphs. Possible values are True and False.";


TetCSimplify::usage="Expects a combination of c[] and performs topological simplifications.";


$Assumptions=DeleteDuplicates[If[Length[$Assumptions]>0,Append[$Assumptions,tau[2]>0],{tau[2]>0}]];


Begin["`Private`"]


MakeBoxes[zeta[k___],StandardForm]:=SubscriptBox["\[Zeta]",RowBox[If[Length[{k}]>1,Riffle[ToBoxes/@{k},","],{ToBoxes[k]}]]];
MakeExpression[SubscriptBox["\[Zeta]",k_?(Head[#]=!=RowBox&)],StandardForm]:=HoldComplete[zeta[ToExpression[k]]];
MakeExpression[SubscriptBox["\[Zeta]",RowBox[k_]],StandardForm]:=HoldComplete[zeta@@ToExpression[k/.","->Nothing]];

MakeBoxes[s[k___],StandardForm]:=SubscriptBox["s",RowBox[If[Length[{k}]>1,Riffle[ToBoxes/@{k},","],{ToBoxes[k]}]]];
MakeExpression[SubscriptBox["s",k_?(Head[#]=!=RowBox&)],StandardForm]:=HoldComplete[s[ToExpression[k]]];
MakeExpression[SubscriptBox["s",RowBox[k_]],StandardForm]:=HoldComplete[s@@ToExpression[k/.","->Nothing]];

MakeBoxes[tau,StandardForm]:="\[Tau]";
\[Tau]:=tau;

MakeBoxes[tauBar,StandardForm]:=OverscriptBox["\[Tau]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.2]];
MakeExpression[OverscriptBox["\[Tau]","_"],StandardForm]:=HoldComplete[tauBar];

MakeBoxes[tau[2],StandardForm]:=SubscriptBox["\[Tau]","2"];
MakeExpression[SubscriptBox["\[Tau]","2"],StandardForm]:=HoldComplete[tau[2]];

MakeBoxes[eta,StandardForm]:="\[Eta]";
\[Eta]:=eta;

MakeBoxes[etaBar,StandardForm]:=OverscriptBox["\[Eta]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.2]];
MakeExpression[OverscriptBox["\[Eta]","_"],StandardForm]:=HoldComplete[etaBar];

MakeBoxes[eta[k___],StandardForm]:=SubscriptBox["\[Eta]",RowBox[If[Length[{k}]>1,Riffle[ToBoxes/@{k},","],{ToBoxes[k]}]]];
MakeExpression[SubscriptBox["\[Eta]",k_?(Head[#]=!=RowBox&)],StandardForm]:=HoldComplete[eta[ToExpression[k]]];
MakeExpression[SubscriptBox["\[Eta]",RowBox[k_]],StandardForm]:=HoldComplete[eta@@ToExpression[k/.","->Nothing]];

MakeBoxes[etaBar[k___],StandardForm]:=SubscriptBox[OverscriptBox["\[Eta]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.2]],RowBox[If[Length[{k}]>1,Riffle[ToBoxes/@{k},","],{ToBoxes[k]}]]];
MakeExpression[SubscriptBox[OverscriptBox["\[Eta]","_"],k_?(Head[#]=!=RowBox&)],StandardForm]:=HoldComplete[etaBar[ToExpression[k]]];
MakeExpression[SubscriptBox[OverscriptBox["\[Eta]","_"],RowBox[k_]],StandardForm]:=HoldComplete[etaBar@@ToExpression[k/.","->Nothing]];


MakeBoxes[g[k_],StandardForm]:=SubscriptBox["G",ToBoxes[k]];
MakeExpression[SubscriptBox["G",k_],StandardForm]:=HoldComplete[g[ToExpression[k]]];

MakeBoxes[gBar[k_],StandardForm]:=SubscriptBox[OverscriptBox["G",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.2]],ToBoxes[k]];
MakeExpression[SubscriptBox[OverscriptBox["G","_"],k_],StandardForm]:=HoldComplete[gBar[ToExpression[k]]];

MakeBoxes[gHat[2],StandardForm]:=SubscriptBox[OverscriptBox["G","^"],"2"];
MakeExpression[SubscriptBox[OverscriptBox["G","^"],"2"],StandardForm]:=HoldComplete[gHat[2]];

MakeBoxes[gBarHat[2],StandardForm]:=SubscriptBox[OverscriptBox[OverscriptBox["G",AdjustmentBox["_",BaseStyle->Bold]],AdjustmentBox["^",BaseStyle->Bold]],"2"]
MakeExpression[SubscriptBox[OverscriptBox[OverscriptBox["G","_"],"^"],"2"],StandardForm]:=HoldComplete[gBarHat[2]];

MakeBoxes[e[k__],StandardForm]:=SubscriptBox["E",RowBox[If[Length[{k}]>1,Riffle[ToBoxes/@{k},","],{ToBoxes[k]}]]];
MakeExpression[SubscriptBox["E",k_?(Head[#]=!=RowBox&)],StandardForm]:=HoldComplete[e[ToExpression[k]]];
MakeExpression[SubscriptBox["E",RowBox[k_]],StandardForm]:=HoldComplete[e@@ToExpression[k/.","->Nothing]];

MakeBoxes[ep[k__],StandardForm]:=SubsuperscriptBox["E",RowBox[If[Length[{k}]>1,Riffle[ToBoxes/@{k},","],{ToBoxes[k]}]],"\[Prime]"];
MakeExpression[SubsuperscriptBox["E",k_?(Head[#]=!=RowBox&),"\[Prime]"],StandardForm]:=HoldComplete[ep[ToExpression[k]]];
MakeExpression[SubsuperscriptBox["E",RowBox[k_],"\[Prime]"],StandardForm]:=HoldComplete[ep@@ToExpression[k/.","->Nothing]];


MakeBoxes[b[k__],StandardForm]:=SubscriptBox["B",RowBox[If[Length[{k}]>1,Riffle[ToBoxes/@{k},","],{ToBoxes[k]}]]];
MakeExpression[SubscriptBox["B",k_?(Head[#]=!=RowBox&)],StandardForm]:=HoldComplete[b[ToExpression[k]]];
MakeExpression[SubscriptBox["B",RowBox[k_]],StandardForm]:=HoldComplete[b@@ToExpression[k/.","->Nothing]];


MakeBoxes[bp[k__],StandardForm]:=SubsuperscriptBox["B",RowBox[If[Length[{k}]>1,Riffle[ToBoxes/@{k},","],{ToBoxes[k]}]],"\[Prime]"];
MakeExpression[SubsuperscriptBox["B",k_?(Head[#]=!=RowBox&),"\[Prime]"],StandardForm]:=HoldComplete[bp[ToExpression[k]]];
MakeExpression[SubsuperscriptBox["B",RowBox[k_],"\[Prime]"],StandardForm]:=HoldComplete[bp@@ToExpression[k/.","->Nothing]];


diEntryQ[x_]:=Head[ToExpression[x]]===List&&(ToExpression[x]==={}||First[Dimensions[ToExpression[x]]]==Length[Dimensions[ToExpression[x]]]==2);


MakeBoxes[c[x_?(diEntryQ[#]&&#=!={}&)],StandardForm]:=StyleBox[RowBox[{"C","[",GridBox[x],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"C","[",GridBox[ab_?diEntryQ],"]"}],StandardForm]:=HoldComplete[c[ToExpression[ab]]];

MakeBoxes[a[x_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"A","[",GridBox[x],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"A","[",GridBox[ab_?diEntryQ],"]"}],StandardForm]:=HoldComplete[a[ToExpression[ab]]];

MakeBoxes[intConst[x_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"intConst","[",GridBox[x],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"intConst","[",GridBox[ab_?diEntryQ],"]"}],StandardForm]:=HoldComplete[intConst[ToExpression[ab]]];

MakeBoxes[intConstBar[x_?diEntryQ],StandardForm]:=OverscriptBox[StyleBox[RowBox[{"intConst","[",GridBox[x],"]"}],SpanMaxSize->Infinity],"_"];
MakeExpression[OverscriptBox[RowBox[{"intConst","[",GridBox[ab_?diEntryQ],"]"}],"_"],StandardForm]:=HoldComplete[intConstBar[ToExpression[ab]]];


MakeBoxes[c[x_?diEntryQ,y_?diEntryQ,z_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"C","[",GridBox[{{If[x==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[x]],If[y==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[y]],If[z==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[z]]}},ColumnLines->True],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"C","[",GridBox[{{x_?diEntryQ,y_?diEntryQ,z_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[c[ToExpression[x],ToExpression[y],ToExpression[z]]];

MakeBoxes[a[x_?diEntryQ,y_?diEntryQ,z_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"A","[",GridBox[{{If[x==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[x]],If[y==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[y]],If[z==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[z]]}},ColumnLines->True],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"A","[",GridBox[{{x_?diEntryQ,y_?diEntryQ,z_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[a[ToExpression[x],ToExpression[y],ToExpression[z]]];

MakeBoxes[intConst[x_?diEntryQ,y_?diEntryQ,z_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"intConst","[",GridBox[{{If[x==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[x]],If[y==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[y]],If[z==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[z]]}},ColumnLines->True],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"intConst","[",GridBox[{{x_?diEntryQ,y_?diEntryQ,z_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[intConst[ToExpression[x],ToExpression[y],ToExpression[z]]];

MakeBoxes[intConstBar[x_?diEntryQ,y_?diEntryQ,z_?diEntryQ],StandardForm]:=OverscriptBox[StyleBox[RowBox[{"intConst","[",GridBox[{{If[x==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[x]],If[y==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[y]],If[z==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[z]]}},ColumnLines->True],"]"}],SpanMaxSize->Infinity],"_"];
MakeExpression[OverscriptBox[RowBox[{"intConst","[",GridBox[{{x_?diEntryQ,y_?diEntryQ,z_?diEntryQ}},OptionsPattern[]],"]"}],"_"],StandardForm]:=HoldComplete[intConstBar[ToExpression[x],ToExpression[y],ToExpression[z]]];


MakeBoxes[c[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"C","[",GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]],If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]],If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]]}},ColumnLines->True],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"C","[",GridBox[{{a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[c[ToExpression[a],ToExpression[b],ToExpression[d],ToExpression[e]]];

MakeBoxes[a[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"A","[",GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]],If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]],If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]]}},ColumnLines->True],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"A","[",GridBox[{{f_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[a[ToExpression[f],ToExpression[b],ToExpression[d],ToExpression[e]]];

MakeBoxes[intConst[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"intConst","[",GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]],If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]],If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]]}},ColumnLines->True],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"intConst","[",GridBox[{{f_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[intConst[ToExpression[f],ToExpression[b],ToExpression[d],ToExpression[e]]];


MakeBoxes[intConstBar[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ],StandardForm]:=OverscriptBox[StyleBox[RowBox[{"intConst","[",GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]],If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]],If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]]}},ColumnLines->True],"]"}],SpanMaxSize->Infinity],"_"];
MakeExpression[OverscriptBox[RowBox[{"intConst","[",GridBox[{{f_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm],"_"]:=HoldComplete[intConstBar[ToExpression[f],ToExpression[b],ToExpression[d],ToExpression[e]]];


MakeBoxes[c[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ,f_?diEntryQ],StandardForm]:=
StyleBox[RowBox[{"C","[",GridBox[{{GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]]}},GridBoxDividers->{"Columns"->{False,{True}}}],AdjustmentBox[GridBox[{{If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]],If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]]}},GridBoxDividers->{"Columns"->{{True}}}],BoxMargins->{{-0.4,0},{0,0}}],AdjustmentBox[GridBox[{{If[f==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[f]]}},GridBoxDividers->{"Columns"->{True,{False}}}],BoxMargins->{{-0.4,0},{0,0}}]}}],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"C","[",GridBox[{{GridBox[{{a_?diEntryQ,b_?diEntryQ}},OptionsPattern[]],GridBox[{{d_?diEntryQ,e_?diEntryQ}},OptionsPattern[]],GridBox[{{f_?diEntryQ}},OptionsPattern[]]}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[c[ToExpression[a],ToExpression[b],ToExpression[d],ToExpression[e],ToExpression[f]]];

MakeBoxes[a[c_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ,f_?diEntryQ],StandardForm]:=
StyleBox[RowBox[{"A","[",GridBox[{{GridBox[{{If[c==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[c]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]]}},GridBoxDividers->{"Columns"->{False,{True}}}],AdjustmentBox[GridBox[{{If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]],If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]]}},GridBoxDividers->{"Columns"->{{True}}}],BoxMargins->{{-0.4,0},{0,0}}],AdjustmentBox[GridBox[{{If[f==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[f]]}},GridBoxDividers->{"Columns"->{True,{False}}}],BoxMargins->{{-0.4,0},{0,0}}]}}],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"A","[",GridBox[{{GridBox[{{c_?diEntryQ,b_?diEntryQ}},OptionsPattern[]],GridBox[{{d_?diEntryQ,e_?diEntryQ}},OptionsPattern[]],GridBox[{{f_?diEntryQ}},OptionsPattern[]]}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[a[ToExpression[c],ToExpression[b],ToExpression[d],ToExpression[e],ToExpression[f]]];

MakeBoxes[intConst[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ,f_?diEntryQ],StandardForm]:=
StyleBox[RowBox[{"intConst","[",GridBox[{{GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]]}},GridBoxDividers->{"Columns"->{False,{True}}}],AdjustmentBox[GridBox[{{If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]],If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]]}},GridBoxDividers->{"Columns"->{{True}}}],BoxMargins->{{-0.4,0},{0,0}}],AdjustmentBox[GridBox[{{If[f==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[f]]}},GridBoxDividers->{"Columns"->{True,{False}}}],BoxMargins->{{-0.4,0},{0,0}}]}}],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"intConst","[",GridBox[{{GridBox[{{a_?diEntryQ,b_?diEntryQ}},OptionsPattern[]],GridBox[{{d_?diEntryQ,e_?diEntryQ}},OptionsPattern[]],GridBox[{{f_?diEntryQ}},OptionsPattern[]]}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[intConst[ToExpression[a],ToExpression[b],ToExpression[d],ToExpression[e],ToExpression[f]]];

MakeBoxes[intConstBar[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ,f_?diEntryQ],StandardForm]:=
OverscriptBox[StyleBox[RowBox[{"intConst","[",GridBox[{{GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]]}},GridBoxDividers->{"Columns"->{False,{True}}}],AdjustmentBox[GridBox[{{If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]],If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]]}},GridBoxDividers->{"Columns"->{{True}}}],BoxMargins->{{-0.4,0},{0,0}}],AdjustmentBox[GridBox[{{If[f==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[f]]}},GridBoxDividers->{"Columns"->{True,{False}}}],BoxMargins->{{-0.4,0},{0,0}}]}}],"]"}],SpanMaxSize->Infinity],"_"];
MakeExpression[OverscriptBox[RowBox[{"intConst","[",GridBox[{{GridBox[{{a_?diEntryQ,b_?diEntryQ}},OptionsPattern[]],GridBox[{{d_?diEntryQ,e_?diEntryQ}},OptionsPattern[]],GridBox[{{f_?diEntryQ}},OptionsPattern[]]}},OptionsPattern[]],"]"}],"_"],StandardForm]:=HoldComplete[intConstBar[ToExpression[a],ToExpression[b],ToExpression[d],ToExpression[e],ToExpression[f]]];


MakeBoxes[c[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ,f_?diEntryQ,g_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"C","[",GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]],If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]]},{If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]],If[f==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[f]],If[g==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[g]]}},ColumnLines->True,RowLines->True],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"C","[",GridBox[{{a_?diEntryQ,b_?diEntryQ,d_?diEntryQ},{e_?diEntryQ,f_?diEntryQ,g_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[c[ToExpression[a],ToExpression[b],ToExpression[d],ToExpression[e],ToExpression[f],ToExpression[g]]];

MakeBoxes[a[c_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ,f_?diEntryQ,g_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"A","[",GridBox[{{If[c==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[c]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]],If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]]},{If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]],If[f==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[f]],If[g==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[g]]}},ColumnLines->True,RowLines->True],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"A","[",GridBox[{{c_?diEntryQ,b_?diEntryQ,d_?diEntryQ},{e_?diEntryQ,f_?diEntryQ,g_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[a[ToExpression[c],ToExpression[b],ToExpression[d],ToExpression[e],ToExpression[f],ToExpression[g]]];

MakeBoxes[intConst[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ,f_?diEntryQ,g_?diEntryQ],StandardForm]:=StyleBox[RowBox[{"intConst","[",GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]],If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]]},{If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]],If[f==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[f]],If[g==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[g]]}},ColumnLines->True,RowLines->True],"]"}],SpanMaxSize->Infinity];
MakeExpression[RowBox[{"intConst","[",GridBox[{{c_?diEntryQ,b_?diEntryQ,d_?diEntryQ},{e_?diEntryQ,f_?diEntryQ,g_?diEntryQ}},OptionsPattern[]],"]"}],StandardForm]:=HoldComplete[intConst[ToExpression[c],ToExpression[b],ToExpression[d],ToExpression[e],ToExpression[f],ToExpression[g]]];

MakeBoxes[intConstBar[a_?diEntryQ,b_?diEntryQ,d_?diEntryQ,e_?diEntryQ,f_?diEntryQ,g_?diEntryQ],StandardForm]:=OverscriptBox[StyleBox[RowBox[{"intConst","[",GridBox[{{If[a==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[a]],If[b==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[b]],If[d==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[d]]},{If[e==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[e]],If[f==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[f]],If[g==={},AdjustmentBox[ToBoxes[{}],BoxMargins->{{0,0},{1.2,1.2}}],GridBox[g]]}},ColumnLines->True,RowLines->True],"]"}],SpanMaxSize->Infinity],"_"];
MakeExpression[OverscriptBox[RowBox[{"intConst","[",GridBox[{{c_?diEntryQ,b_?diEntryQ,d_?diEntryQ},{e_?diEntryQ,f_?diEntryQ,g_?diEntryQ}},OptionsPattern[]],"]"}],"_"],StandardForm]:=HoldComplete[intConstBar[ToExpression[c],ToExpression[b],ToExpression[d],ToExpression[e],ToExpression[f],ToExpression[g]]];


nablaE[0,k_]:=e@@k;
nablaEp[0,k_]:=ep@@k;
nablaBarE[0,k_]:=e@@k;
nablaBarEp[0,k_]:=ep@@k;
nablaB[0,k_]:=b@@k;
nablaBp[0,k_]:=bp@@k;
nablaBarB[0,k_]:=CComplexConj[b@@k];
nablaBarBpBar[0,k_]:=CComplexConj[bp@@k];


MakeBoxes[nablaE[n_,k_],StandardForm]:=RowBox[{If[n>1,SuperscriptBox["\[Del]",n],If[n==1,"\[Del]"]],SubscriptBox["E",RowBox[If[Length[k]>1,Riffle[k,","],k]]]}]
MakeExpression[RowBox[{SuperscriptBox["\[Del]",n_],SubscriptBox["E",RowBox[k_]]}],StandardForm]:=HoldComplete[nablaE[ToExpression[n],ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{"\[Del]",SubscriptBox["E",RowBox[k_]]}],StandardForm]:=HoldComplete[nablaE[1,ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{SuperscriptBox["\[Del]",n_],SubscriptBox["E",k_]}],StandardForm]:=HoldComplete[nablaE[ToExpression[n],{ToExpression[k]}]]
MakeExpression[RowBox[{"\[Del]",SubscriptBox["E",k_]}],StandardForm]:=HoldComplete[nablaE[1,{ToExpression[k]}]]

MakeBoxes[nablaEp[n_,k_],StandardForm]:=RowBox[{If[n>1,SuperscriptBox["\[Del]",n],If[n==1,"\[Del]"]],SubsuperscriptBox["E",RowBox[If[Length[k]>1,Riffle[k,","],k]],"\[Prime]"]}]
MakeExpression[RowBox[{SuperscriptBox["\[Del]",n_],SubsuperscriptBox["E",RowBox[k_],"\[Prime]"]}],StandardForm]:=HoldComplete[nablaEp[ToExpression[n],ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{"\[Del]",SubsuperscriptBox["E",RowBox[k_],"\[Prime]"]}],StandardForm]:=HoldComplete[nablaEp[1,ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{SuperscriptBox["\[Del]",n_],SubsuperscriptBox["E",k_,"\[Prime]"]}],StandardForm]:=HoldComplete[nablaEp[ToExpression[n],{ToExpression[k]}]]
MakeExpression[RowBox[{"\[Del]",SubsuperscriptBox["E",k_,"\[Prime]"]}],StandardForm]:=HoldComplete[nablaEp[1,{ToExpression[k]}]]

MakeBoxes[nablaBarE[n_,k_],StandardForm]:=RowBox[{If[n>1,SuperscriptBox[OverscriptBox["\[Del]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.3]],n],If[n==1,OverscriptBox["\[Del]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.3]],Nothing]],SubscriptBox["E",RowBox[If[Length[k]>1,Riffle[k,","],k]]]}]
MakeExpression[RowBox[{SuperscriptBox[OverscriptBox["\[Del]","_"],n_],SubscriptBox["E",RowBox[k_]]}],StandardForm]:=HoldComplete[nablaBarE[ToExpression[n],ToExpression[k/.","->Nothing]]];
MakeExpression[RowBox[{OverscriptBox["\[Del]","_"],SubscriptBox["E",RowBox[k_]]}],StandardForm]:=HoldComplete[nablaBarE[1,ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{SuperscriptBox[OverscriptBox["\[Del]","_"],n_],SubscriptBox["E",k_]}],StandardForm]:=HoldComplete[nablaBarE[ToExpression[n]1,{ToExpression[k]}]]
MakeExpression[RowBox[{OverscriptBox["\[Del]","_"],SubscriptBox["E",k_]}],StandardForm]:=HoldComplete[nablaBarE[1,{ToExpression[k]}]]

MakeBoxes[nablaBarEp[n_,k_],StandardForm]:=RowBox[{If[n>1,SuperscriptBox[OverscriptBox["\[Del]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.3]],n],If[n==1,OverscriptBox["\[Del]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.3]],Nothing]],SubsuperscriptBox["E",RowBox[If[Length[k]>1,Riffle[k,","],k]],"\[Prime]"]}]
MakeExpression[RowBox[{SuperscriptBox[OverscriptBox["\[Del]","_"],n_],SubsuperscriptBox["E",RowBox[k_],"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBarEp[ToExpression[n],ToExpression[k/.","->Nothing]]];
MakeExpression[RowBox[{OverscriptBox["\[Del]","_"],SubsuperscriptBox["E",RowBox[k_],"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBarEp[1,ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{SuperscriptBox[OverscriptBox["\[Del]","_"],n_],SubsuperscriptBox["E",k_,"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBarEp[ToExpression[n]1,{ToExpression[k]}]]
MakeExpression[RowBox[{OverscriptBox["\[Del]","_"],SubsuperscriptBox["E",k_,"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBarEp[1,{ToExpression[k]}]]


MakeBoxes[nablaB[n_,k_],StandardForm]:=RowBox[{If[n>1,SuperscriptBox["\[Del]",n],If[n==1,"\[Del]"]],SubscriptBox["B",RowBox[If[Length[k]>1,Riffle[k,","],k]]]}]
MakeExpression[RowBox[{SuperscriptBox["\[Del]",n_],SubscriptBox["B",RowBox[k_]]}],StandardForm]:=HoldComplete[nablaB[ToExpression[n],ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{"\[Del]",SubscriptBox["B",RowBox[k_]]}],StandardForm]:=HoldComplete[nablaB[1,ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{SuperscriptBox["\[Del]",n_],SubscriptBox["B",k_]}],StandardForm]:=HoldComplete[nablaB[ToExpression[n],{ToExpression[k]}]]
MakeExpression[RowBox[{"\[Del]",SubscriptBox["B",k_]}],StandardForm]:=HoldComplete[nablaB[1,{ToExpression[k]}]]

MakeBoxes[nablaBp[n_,k_],StandardForm]:=RowBox[{If[n>1,SuperscriptBox["\[Del]",n],If[n==1,"\[Del]"]],SubsuperscriptBox["B",RowBox[If[Length[k]>1,Riffle[k,","],k]],"\[Prime]"]}]
MakeExpression[RowBox[{SuperscriptBox["\[Del]",n_],SubsuperscriptBox["B",RowBox[k_],"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBp[ToExpression[n],ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{"\[Del]",SubsuperscriptBox["B",RowBox[k_],"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBp[1,ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{SuperscriptBox["\[Del]",n_],SubsuperscriptBox["B",k_,"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBp[ToExpression[n],{ToExpression[k]}]]
MakeExpression[RowBox[{"\[Del]",SubsuperscriptBox["B",k_,"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBp[1,{ToExpression[k]}]]

MakeBoxes[nablaBarBBar[n_,k_],StandardForm]:=RowBox[{If[n>1,SuperscriptBox[OverscriptBox["\[Del]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.3]],n],If[n==1,OverscriptBox["\[Del]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.3]],Nothing]],SubscriptBox[OverscriptBox["B",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.2]],RowBox[If[Length[k]>1,Riffle[k,","],k]]]}]
MakeExpression[RowBox[{SuperscriptBox[OverscriptBox["\[Del]","_"],n_],SubscriptBox[OverscriptBox["B","_"],RowBox[k_]]}],StandardForm]:=HoldComplete[nablaBarBBar[ToExpression[n],ToExpression[k/.","->Nothing]]];
MakeExpression[RowBox[{OverscriptBox["\[Del]","_"],SubscriptBox[OverscriptBox["B","_"],RowBox[k_]]}],StandardForm]:=HoldComplete[nablaBarBBar[1,ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{SuperscriptBox[OverscriptBox["\[Del]","_"],n_],SubscriptBox[OverscriptBox["B","_"],k_]}],StandardForm]:=HoldComplete[nablaBarBBar[ToExpression[n]1,{ToExpression[k]}]]
MakeExpression[RowBox[{OverscriptBox["\[Del]","_"],SubscriptBox[OverscriptBox["B","_"],k_]}],StandardForm]:=HoldComplete[nablaBarBBar[1,{ToExpression[k]}]]

MakeBoxes[nablaBarBpBar[n_,k_],StandardForm]:=RowBox[{If[n>1,SuperscriptBox[OverscriptBox["\[Del]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.3]],n],If[n==1,OverscriptBox["\[Del]",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.3]],Nothing]],SubsuperscriptBox[OverscriptBox["B",AdjustmentBox["_",BaseStyle->Bold,BoxBaselineShift->-0.2]],RowBox[If[Length[k]>1,Riffle[k,","],k]],"\[Prime]"]}]
MakeExpression[RowBox[{SuperscriptBox[OverscriptBox["\[Del]","_"],n_],SubsuperscriptBox[OverscriptBox["B","_"],RowBox[k_],"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBarBpBar[ToExpression[n],ToExpression[k/.","->Nothing]]];
MakeExpression[RowBox[{OverscriptBox["\[Del]","_"],SubsuperscriptBox[OverscriptBox["B","_"],RowBox[k_],"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBarBpBar[1,ToExpression[k/.","->Nothing]]]
MakeExpression[RowBox[{SuperscriptBox[OverscriptBox["\[Del]","_"],n_],SubsuperscriptBox[OverscriptBox["B","_"],k_,"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBarBpBar[ToExpression[n]1,{ToExpression[k]}]]
MakeExpression[RowBox[{OverscriptBox["\[Del]","_"],SubsuperscriptBox[OverscriptBox["B","_"],k_,"\[Prime]"]}],StandardForm]:=HoldComplete[nablaBarBpBar[1,{ToExpression[k]}]]


MakeBoxes[esv[jk_?(diEntryQ[#]&&#=!={}&)],StandardForm]:=RowBox[{SuperscriptBox["\[ScriptCapitalE]","sv"],"[",GridBox[jk],"]"}];
MakeExpression[RowBox[{SuperscriptBox["\[ScriptCapitalE]","sv"],"[",GridBox[jk_?diEntryQ],"]"}],StandardForm]:=HoldComplete[esv[ToExpression[jk]]];

MakeBoxes[esvBar[jk_?(diEntryQ[#]&&#=!={}&)],StandardForm]:=OverscriptBox[RowBox[{SuperscriptBox["\[ScriptCapitalE]","sv"],"[",GridBox[jk],"]"}],"_"];
MakeExpression[OverscriptBox[RowBox[{SuperscriptBox["\[ScriptCapitalE]","sv"],"[",GridBox[jk_?diEntryQ],"]"}],"_"],StandardForm]:=HoldComplete[esvBar[ToExpression[jk]]];

MakeBoxes[esvS[jk_?(diEntryQ[#]&&#=!={}&)],StandardForm]:=RowBox[{SubsuperscriptBox["\[ScriptCapitalE]",RowBox[{"-",FractionBox["1","\[Tau]"]}],"sv"],"[",GridBox[jk],"]"}];
MakeExpression[RowBox[{SubsuperscriptBox["\[ScriptCapitalE]",RowBox[{"-",FractionBox["1","\[Tau]"]}],"sv"],"[",GridBox[jk_?diEntryQ],"]"}],StandardForm]:=HoldComplete[esvS[ToExpression[jk]]];

MakeBoxes[betasv[jk_?(diEntryQ[#]&&#=!={}&)],StandardForm]:=RowBox[{SuperscriptBox["\[Beta]","sv"],"[",GridBox[jk],"]"}];
MakeExpression[RowBox[{SuperscriptBox["\[Beta]","sv"],"[",GridBox[jk_?diEntryQ],"]"}],StandardForm]:=HoldComplete[betasv[ToExpression[jk]]];

MakeBoxes[betasvBar[jk_?(diEntryQ[#]&&#=!={}&)],StandardForm]:=OverscriptBox[RowBox[{SuperscriptBox["\[Beta]","sv"],"[",GridBox[jk],"]"}],"_"];
MakeExpression[OverscriptBox[RowBox[{SuperscriptBox["\[Beta]","sv"],"[",GridBox[jk_?diEntryQ],"]"}],"_"],StandardForm]:=HoldComplete[betasvBar[ToExpression[jk]]];

MakeBoxes[betasvS[jk_?(diEntryQ[#]&&#=!={}&)],StandardForm]:=RowBox[{SubsuperscriptBox["\[Beta]",RowBox[{"-",FractionBox["1","\[Tau]"]}],"sv"],"[",GridBox[jk],"]"}];
MakeExpression[RowBox[{SubsuperscriptBox["\[Beta]",RowBox[{"-",FractionBox["1","\[Tau]"]}],"sv"],"[",GridBox[jk_?diEntryQ],"]"}],StandardForm]:=HoldComplete[betasvS[ToExpression[jk]]];


MakeBoxes[fz[n_,i_,j_],StandardForm]:=SubsuperscriptBox["f",RowBox[{MakeBoxes[i,StandardForm],",",MakeBoxes[j,StandardForm]}],RowBox[{"(",MakeBoxes[n,StandardForm],")"}]]
MakeExpression[SubsuperscriptBox["f",RowBox[{i_,",",j_}],RowBox[{"(",n_,")"}]],StandardForm]:=MakeExpression[RowBox[{"fz","[",RowBox[{n,",",i,",",j}],"]"}],StandardForm]

MakeBoxes[fBarz[n_,i_,j_],StandardForm]:=SubsuperscriptBox[OverscriptBox["f","_"],RowBox[{MakeBoxes[i,StandardForm],",",MakeBoxes[j,StandardForm]}],RowBox[{"(",MakeBoxes[n,StandardForm],")"}]]
MakeExpression[SubsuperscriptBox[OverscriptBox["f","_"],RowBox[{i_,",",j_}],RowBox[{"(",n_,")"}]],StandardForm]:=MakeExpression[RowBox[{"fBarz","[",RowBox[{n,",",i,",",j}],"]"}],StandardForm]

MakeBoxes[gz[i_,j_],StandardForm]:=SubscriptBox["G",RowBox[{MakeBoxes[i,StandardForm],",",MakeBoxes[j,StandardForm]}]]
MakeExpression[SubscriptBox["G",RowBox[{i_,",",j_}]],StandardForm]:=MakeExpression[RowBox[{"gz","[",RowBox[{i,",",j}],"]"}],StandardForm]

MakeBoxes[cz[a_,b_,i_,j_],StandardForm]:=SubsuperscriptBox["C",RowBox[{MakeBoxes[i,StandardForm],",",MakeBoxes[j,StandardForm]}],RowBox[{"(",MakeBoxes[a,StandardForm],",",MakeBoxes[b,StandardForm],")"}]]
MakeExpression[SubsuperscriptBox["C",RowBox[{i_,",",j_}],RowBox[{"(",a_,",",b_,")"}]],StandardForm]:=MakeExpression[RowBox[{"cz","[",RowBox[{a,",",b,",",i,",",j}],"]"}],StandardForm]


ModularGraphForms::NoDiIdsFile="Dihedral identity file could not be found at `1`";
ModularGraphForms::NoTriIdsFile="Trihedral identity file could not be found at `1`";
packageDir=If[$InputFileName=="",NotebookDirectory[],DirectoryName[$InputFileName]];
If[FileExistsQ[packageDir<>"DiIds.txt"],
Print["Dihedral identity file found at "<>packageDir<>"DiIds.txt"];,
Message[ModularGraphForms::NoDiIdsFile,packageDir<>"DiIds.txt"];]
If[FileExistsQ[packageDir<>"TriIds.txt"],
Print["Trihedral identity file found at "<>packageDir<>"TriIds.txt"];,
Message[ModularGraphForms::NoTriIdsFile,packageDir<>"TriIds.txt"];]


prepCol::usage="Prepends a column to a (possibly empty) matrix";prepCol[col_,mat_]:=If[mat=={},List/@col,saveT[Prepend[saveT[mat],col]]];


saveT::usage="Transposes matrix and returns the empty list if an empty list is passed as an argument";
saveT[mat_]:=If[mat==={},{},Transpose[mat]];


CCheckConv[exp_]:=Block[{ab=0,r=0},
FixedPoint[If[FreeQ[#,c[_]],#,
ab=Cases[{#},c[_],Infinity][[1]]/.c->Identity;
r=Dimensions[ab][[2]];
If[2(r-1)>= Total[ab[[1]]]+Total[ab[[2]]],Return[False]];
If[Min[Total/@Subsets[Total/@saveT[ab],{2}]]<=2,Return[False]];
#/.c[ab]->1]&,
exp];
FixedPoint[If[FreeQ[#,c[_,_,_]],#,
ab=List@@(Cases[{#},c[_,_,_],Infinity][[1]]);
If[2(Length[Flatten[#[[1]]&/@ab]]-2)>=Total[ab,3],Return[False]];
If[Or@@((Min[Total/@Subsets[Total/@saveT[#],{2}]]<=2&)/@ab),Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab)]<=2,Return[False]];
#/.c@@ab->1]&,
exp];
FixedPoint[If[FreeQ[#,c[_,_,_,_]],#,
ab=List@@(Cases[{#},c[_,_,_,_],Infinity][[1]]);
If[Or@@((Min[Total/@Subsets[Total/@saveT[#],{2}]]<=2&)/@ab),Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab)]<=2,Return[False]];
#/.c@@ab->1]&,
exp];
FixedPoint[If[FreeQ[#,c[_,_,_,_,_]],#,
ab=List@@(Cases[{#},c[_,_,_,_,_],Infinity][[1]]);
If[Or@@((Min[Total/@Subsets[Total/@saveT[#],{2}]]<=2&)/@ab),Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{1,2,3,4}]])]<=2,Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{1,2,5}]])]<=2,Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{3,4,5}]])]<=2,Return[False]];
#/.c@@ab->1]&,
exp];
FixedPoint[If[FreeQ[#,c[_,_,_,_,_,_]],#,
ab=List@@(Cases[{#},c[_,_,_,_,_,_],Infinity][[1]]);
If[Or@@((Min[Total/@Subsets[Total/@saveT[#],{2}]]<=2&)/@ab),Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{1,2,6}]])]<=2,Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{1,3,5}]])]<=2,Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{2,3,4}]])]<=2,Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{4,5,6}]])]<=2,Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{2,3,5,6}]])]<=2,Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{1,3,4,6}]])]<=2,Return[False]];
If[Total[Min/@(Total/@(saveT[#])&/@ab[[{1,2,4,5}]])]<=2,Return[False]];
#/.c@@ab->1]&,
exp];
If[!FreeQ[exp,(e[n_]/;n<2)|(g[n_]/;n<2)|(gBar[n_]/;n<2)],Return[False],Return[True]]
];


messageOnce::usage="Issue warning only if it hasn\[CloseCurlyQuote]t been issued before in the same run of CSimplify";

(*prevent evaluation of arguments so that variable and message are passed to the function, not just their values*)
SetAttributes[messageOnce,HoldAll];
messageOnce[listVar_,mess_,messArgs___]:=(If[!MemberQ[listVar,StringForm[mess,messArgs]],Message[mess,messArgs]];AppendTo[listVar,StringForm[mess,messArgs]];)
(*initialize warnings*)
cSimplifyWarnings={};
insideCSimplify=False;


diMomentumCons::usage="Expects a matrix representing a dihedral MGF and length-2 list describing the position of a -1 that is to be removed by momentum conservation.
Returns a linear combination of c[].";

diMomentumCons[AB_,pos_]:=Block[{r=Dimensions[AB][[2]],i=pos[[1]],j=pos[[2]],s,result},
If[Cases[AB[[i]],x_/;x<=0]!={-1},Return[c[AB]],Nothing];
result=c[AB];
s[k_]:=SparseArray[{{i,k}->1},{2,r}];
If[!CCheckConv[c[AB+s[j]]],Return[result]];
result=result-Sum[c[AB-s[n]+s[j]],{n,1,r}];
Return[result]];


diMomSimplify::usage="Expects an expression containing dihedral MGFs and remove all negative entries of -1 when possible.";
diMomSimplify[lincomb_]:=Block[{result=lincomb},
result=result//.c[x_]/;Length[Position[x,-1]]>=1:>diMomentumCons[x,Position[x,-1][[1]]];
Return[result/.c[ab_]/;Dimensions[ab]!={2,2}:>c[saveT[Sort[saveT[ab]]]]]];


DiHolMomConsId::divDiHolMomCons="You are generating the holomorphic momentum conservation identity of the divergent seed `1`. Divergent seeds can lead to inconsistent identities.";
DiHolMomConsId[c[exp_]]:=Block[{n,ab=0,r=0,result=0},
If[!CCheckConv[c[exp]],Message[DiHolMomConsId::divDiHolMomCons,c[exp]];];
ab=exp;
r=Dimensions[ab][[2]];
result=Sum[c[MapAt[#-1&,ab,{1,i}]],{i,1,r}];
Return[result==0];
];


DiAHolMomConsId::divDiAHolMomCons="You are generating the antiholomorphic momentum conservation identity of the divergent seed `1`. Divergent seeds can lead to inconsistent identities.";
DiAHolMomConsId[c[exp_]]:=Block[{n,ab=0,r=0,result=0},
If[!CCheckConv[c[exp]],Message[DiAHolMomConsId::divDiAHolMomCons,c[exp]];];
ab=exp;
r=Dimensions[ab][[2]];
result=Sum[c[MapAt[#-1&,ab,{2,i}]],{i,1,r}];
Return[result==0]
];


diFact::usage=
		"Factorizes dihedral MGF given as a matrix with one zero column and returns product of c[].";
diFact[mat_]:=Block[{result,zerocol,redmat,cc=0,shortColList,n},
zerocol=Flatten[Position[saveT[mat],{0,0}]];
If[zerocol=={},Return[result]];
zerocol=zerocol[[1]];
redmat=saveT[Drop[saveT[mat],{zerocol}]];
If[ContainsAny[saveT[redmat],{{1,0},{0,1}}],
messageOnce[cSimplifyWarnings,DiCSimplify::dangerousFact,CSort[c[mat]]];
If[Count[saveT[redmat],{1,0}|{0,1}]>1,Return[c[mat]]];
If[MemberQ[saveT[redmat],{0,1}],cc=1];(*If (0,1)-column use complex conjugated formula*)
shortColList=Delete[Range[Length[saveT[redmat]]],Position[saveT[redmat],{1,0}|{0,1}|{1,1}]];
n=Count[saveT[redmat],{1,1}];
result=-c[redmat];
result+=(\[Pi]/tau[2])^(n+1) Sum[Product[c[{
 {redmat[[1,j]]-cc  KroneckerDelta[i,j], 0},
 {redmat[[2,j]]-(1-cc)KroneckerDelta[i,j], 0}
}],{j,shortColList}],{i,shortColList}]Sum[(-1)^(k+1) n!/(n-k)! e[1]^(n-k),{k,0,n}];
,
result=Product[c[{{mat[[1,i]], 0},{mat[[2,i]], 0}}],{i,Drop[Range[Length[saveT[mat]]],{zerocol}]}]-c[redmat];
];
Return[result]];


diExplicitIdentities::usage=
		"Explicitly known identities for dihedral MGFs";
diExplicitIdentities=If[FileExistsQ[packageDir<>"DiIds.txt"],Get[packageDir<>"DiIds.txt"],{}];
Print["Loaded "<>ToString[Length[diExplicitIdentities]]<>" identities for dihedral MGFs."];


diGSimplify::usage="Expand holomorphic Eisenstein series in the ring of \!\(\*SubscriptBox[\(G\), \(4\)]\) and \!\(\*SubscriptBox[\(G\), \(6\)]\) and perform generalized Ramanujan identities.";

diGSimplify[exp_]:=Block[{finalExp,gSeries,partialGSeries,gDecomp,partialGDecomp},
gSeries[k_,n_]:=2 Zeta[k]-4 k Zeta[k]/BernoulliB[k] Sum[DivisorSigma[k-1,j] q^j,{j,1,n}]+O[q]^(n+1);
partialGSeries[l_,k_]:=2 Zeta[l-1]+(-1)^l 4 Zeta[l-1]/BernoulliB[l-1] Sum[DivisorSigma[l-2,j] (l-1-4 \[Pi] j tau[2]) q^j,{j,1,k}]+O[q]^(k+1);
gDecomp[k_]:=Block[{result,basis,fourierseries},
basis=Times@@@Map[g,IntegerPartitions[k,All,{4,6}],{2}];
fourierseries=CoefficientList[#,q]&/@(basis/.g[n_]:>(gSeries[n,Length[basis]-1]));
result=LinearSolve[saveT[fourierseries],CoefficientList[gSeries[k,Length[basis]-1],q]];
result=result.basis;
result];
partialGDecomp[k_]:=Block[{result,basis,fourierseries},
basis=Times@@@Map[g,IntegerPartitions[k+1,All,{4,6}],{2}];
fourierseries=CoefficientList[#,q]&/@(basis/.g[n_]:>(gSeries[n,Length[basis]-1]));
result=LinearSolve[saveT[fourierseries],CoefficientList[gSeries[k-1,Length[basis]-1]gSeries[2,Length[basis]-1]-\[Pi]/tau[2] gSeries[k-1,Length[basis]-1]+\[Pi]/tau[2] partialGSeries[k,Length[basis]-1],q]];
result=result.basis;
result=tau[2]/\[Pi] (result-g[k-1]gHat[2]);
result];
finalExp=exp/.{g[k_]/;OddQ[k]->0,gBar[k_]/;OddQ[k]->0};
finalExp=finalExp/.{c[{
 {3, 0},
 {-1, 0}
}]->tau[2]/\[Pi] (5/2 g[4]-1/2 gHat[2]^2),c[{
 {-1, 0},
 {3, 0}
}]->tau[2]/\[Pi] (5/2 gBar[4]-1/2 gBarHat[2]^2)};
finalExp=finalExp/.c[{
 {k_, 0},
 {-1, 0}
}]/;k>3:>partialGDecomp[k];
finalExp=finalExp/.c[{
 {-1, 0},
 {k_, 0}
}]/;k>3:>(partialGDecomp[k]/.{g->gBar,gHat->gBarHat});
finalExp=finalExp/.{c[{
 {k_, 0},
 {n_, 0}
}]/;EvenQ[k+n]&&n<-1&&k>-n:>((k+n-1)!/(k-1)! Nest[DiLimCSimplify[Quiet[CHolCR[#]],basisExpandG->True]&,c[{
 {k+n, 0},
 {0, 0}
}],-n]),c[{
 {n_, 0},
 {k_, 0}
}]/;EvenQ[k+n]&&n<-1&&k>-n:>((k+n-1)!/(k-1)! Nest[DiLimCSimplify[Quiet[CAHolCR[#]],basisExpandG->True]&,c[{
 {0, 0},
 {k+n, 0}
}],-n])};
finalExp=finalExp/.g[k_]/;k>=8:>gDecomp[k];
finalExp=finalExp/.gBar[k_]/;k>=8:>(gDecomp[k]/.g->gBar);
Return[finalExp]];


diLimCSimplify::usage="Perform simplifications of dihedral graphs, apart from explicit identities and HSR.";
Options[diLimCSimplify]={basisExpandG->False,momSimplify->True,repGHat2->True};
DiCSimplify::wrongRepGHat2Arg="Wrong argument \"`1`\" for repGHat2: Allowed are only True and False.";
DiCSimplify::wrongUsebasisExpandGArg="Wrong argument \"`1`\" for basisExpandG: Allowed are only True and False.";
DiCSimplify::wrongArgMomSimplify="Wrong argument \"`1`\" for momSimplify: Allowed are only True and False.";
DiCSimplify::dangerousFact="The graph `1` is factorized and contains a (1,0) or (0,1) column. This may be problematic.";
diLimCSimplify[lincomb_,opts:OptionsPattern[]]:=Block[{result=lincomb},
If[ContainsNone[{True,False},{OptionValue[repGHat2]}],messageOnce[cSimplifyWarnings,DiCSimplify::wrongRepGHat2Arg,OptionValue[repGHat2]];
Return[lincomb]];
If[ContainsNone[{True,False},{OptionValue[basisExpandG]}],messageOnce[cSimplifyWarnings,DiCSimplify::wrongUsebasisExpandGArg,OptionValue[basisExpandG]];
Return[lincomb]];
If[ContainsNone[{True,False},{OptionValue[momSimplify]}],messageOnce[cSimplifyWarnings,DiCSimplify::wrongArgMomSimplify,OptionValue[momSimplify]];
Return[lincomb]];
result=result/.c[{}]->1;
result=result/.c[ab_]/;(Position[saveT[ab],{0,0}]!={}&&Dimensions[ab]!={2,1}):>diFact[ab];
result=result/.{c[x_]/;Dimensions[x]=={2,1}->0};
If[OptionValue[momSimplify],result=diMomSimplify[Expand[result]]];
result=result/.c[ab_]/;Dimensions[ab]!={2,2}:>c[saveT[Sort[saveT[ab]]]];
result=result/.c[ab_]/;OddQ[Total[ab,2]]->0;
result=result/.c[ab_]/;Dimensions[ab]=={2,2}:>(-1)^Total[ab[[All,2]]] c[{{Total[ab[[1]]],0},{Total[ab[[2]]],0}}];
result=result/.c[{
 {k_, 0},
 {0, 0}
}]/;k>2:>g[k];
result=result/.c[{
 {0, 0},
 {k_, 0}
}]/;k>2:>gBar[k];
If[OptionValue[repGHat2],result=result/.c[{
 {2, 0},
 {0, 0}
}]->gHat[2];result=result/.c[{
 {0, 0},
 {2, 0}
}]->gBarHat[2];];
result=result/.g[k_]/;OddQ[k]->0;
result=result/.gBar[k_]/;OddQ[k]->0;
result=result/.c[ab_]/;(Dimensions[ab]=={2,2}&&ab[[All,2]]=={0,0}&&ab[[1,1]]==ab[[2,1]]):>(\[Pi]/tau[2])^ab[[1,1]] e[ab[[1,1]]];
If[OptionValue[basisExpandG],result=diGSimplify[result]];
Return[Expand[result]]]
Options[DiLimCSimplify]=Options[diLimCSimplify];
DiLimCSimplify[exp_,opts:OptionsPattern[]]:=FixedPoint[diLimCSimplify[#,opts]&,exp];


diHolSubRed::usage="Expects a matrix which is checked for dihedral holomorphic subgraph reduction and returns a linear combination of c[]. Performs HSR on the first two holomorphic columns.";
Options[diHolSubRed]={divHSR->True,diDivHSR->True};
DiCSimplify::wrongDivHSRArg="Wrong argument \"`1`\" for divHSR: Allowed are only True and False.";
DiCSimplify::wrongDiDivHSRArg="Wrong argument \"`1`\" for diDivHSR: Allowed are only True and False.";
DiCSimplify::divHSRNotPossible="Encountered the divergent HSR-graph `1` but divergent HSR is deactivated.";
diHolSubRed[mat_,opts:OptionsPattern[]]:=Block[{a,apos,abMat,result=0},
If[ContainsNone[{True,False},{OptionValue[divHSR]}],messageOnce[cSimplifyWarnings,DiCSimplify::wrongDivHSRArg,OptionValue[divHSR]];Return[c[mat]]];
If[ContainsNone[{True,False},{OptionValue[diDivHSR]}],messageOnce[cSimplifyWarnings,DiCSimplify::wrongDiDivHSRArg,OptionValue[diDivHSR]];Return[c[mat]]];
If[(OptionValue[divHSR]==False||OptionValue[diDivHSR]==False)&&!CCheckConv[c[mat]],messageOnce[cSimplifyWarnings,DiCSimplify::divHSRNotPossible,c[saveT[Sort[saveT[mat]]]]];Return[c[mat]];];
If[OddQ[Total[mat,-1]],Return[0]];
apos=Flatten[Position[mat[[2]],0]];(*Positions of a
0

 columns*)
a=mat[[1,apos]];(*a values in these colmuns*)
apos=MapIndexed[If[((a[[#]]&)@@#2)<=0,Nothing,#1]&,apos];(*delete positions and values with a\[LessEqual]0*)
a=DeleteCases[a,x_/;x<=0];
If[Length[apos]<2,Return[c[mat]]];
apos=Take[apos,2];(*Select first two columns*)
a=mat[[1,apos]];
abMat=saveT[Delete[saveT[mat],List/@apos]];
If[a[[1]]==a[[2]]==1,
result=-2c[prepCol[{2,0},abMat]]-gHat[2]c[abMat]+\[Pi]/tau[2] c[prepCol[{1,-1},abMat]];
Return[result]];
result=c[Append[{a},{0,0}]]c[abMat]-Binomial[Total[a],a[[2]]]c[prepCol[{Total[a],0},abMat]]+Sum[Binomial[Total[a]-1-k,a[[1]]-k]g[k]c[prepCol[{Total[a]-k,0},abMat]],{k,4,a[[1]]}]+Sum[Binomial[Total[a]-1-k,a[[2]]-k]g[k]c[prepCol[{Total[a]-k,0},abMat]],{k,4,a[[2]]}]+Binomial[Total[a]-2,a[[1]]-1](gHat[2] c[prepCol[{Total[a]-2,0},abMat]]+\[Pi]/\!\(TraditionalForm\`tau[2]\) c[prepCol[{Total[a]-1,-1},abMat]]);Return[result]];


Options[diCSimplify]=DeleteDuplicates[Join[{useIds->True,diHSR->True},Options[diHolSubRed],Options[diLimCSimplify]]];
DiCSimplify::wrongUseIdsArg="Wrong argument \"`1`\" for useIDs: Allowed are only True and False.";
DiCSimplify::wrongdiHSRArg="Wrong argument \"`1`\" for diHSR: Allowed are only True and False.";
diCSimplify[lincomb_,opts:OptionsPattern[]]:=Block[{result=lincomb},
If[ContainsNone[{True,False},{OptionValue[useIds]}],messageOnce[cSimplifyWarnings,DiCSimplify::wrongUseIdsArg,OptionValue[useIds]];Return[lincomb]];
If[ContainsNone[{True,False},{OptionValue[diHSR]}],messageOnce[cSimplifyWarnings,DiCSimplify::wrongdiHSRArg,OptionValue[diHSR]];Return[lincomb]];
If[OptionValue[diHSR],
result=result/.{c[ab_]/;If[ab=={},False,Count[ab[[2]],0]>=2]:>diHolSubRed[ab,FilterRules[{opts}, Options[diHolSubRed]]],c[ab_]/;If[ab=={},False,Count[ab[[1]],0]>=2]:>CComplexConj[diHolSubRed[Reverse[ab],FilterRules[{opts}, Options[diHolSubRed]]]]};
];
result=DiLimCSimplify[result,FilterRules[{opts}, Options[diLimCSimplify]]];
If[OptionValue[useIds],result=result/.c[x_]:>(c[x]/.diExplicitIdentities)];
Return[Expand[result]]];
Options[DiCSimplify]=Options[diCSimplify];
DiCSimplify[exp_,opts:OptionsPattern[]]:=(If[!insideCSimplify,cSimplifyWarnings={}];FixedPoint[diCSimplify[#,opts]&,exp]);


triSort::usage="Sorts trihedral graphs into their canonical representation.";
triSort[exp_]:=exp/.c[x_,y_,z_]:>Sort[c@@(saveT[Sort[saveT[#]]]&/@{x,y,z})];


triRed::usage="Expects three matrices representing a trihedral MGF, where the two matrices have just one column and simplifies it into a dihedral MGF.";
triRed[mat1_,mat2_,mat3_]:=Block[{result,mlist={mat1,mat2,mat3},shortblocks,longblock},
shortblocks=Flatten[Position[mlist,_?(Dimensions[#]=={2,1}&)]];
If[Length[shortblocks]<2,Return[c@@mlist]];
shortblocks=shortblocks[[1;;2]];
longblock=Delete[{1,2,3},List/@shortblocks];
result=triSort[(-1)^Total[mlist[[shortblocks]],-1] c[prepCol[Flatten[{Total[mlist[[shortblocks]][[All,1]],-1],Total[mlist[[shortblocks]][[All,2]],-1]}],mlist[[longblock]][[1]]]]];
Return[result]];


triMomentumCons::usage="Expects three matrices representing a trihedral MGF. Tries to remove antiholomorphic entries of -1 by momentum conservation.";
triMomentumCons[mat1_,mat2_,mat3_]:=Block[{pos,zeros,nonzeros,result,col1,col2,mlist={mat1,mat2,mat3},newmlist},
result=c[mat1,mat2,mat3];
pos=Position[Part[#,2]&/@mlist,-1][[1]];
If[pos=={},Return[result]];
newmlist=ReplacePart[mlist,{pos[[1]],2,pos[[2]]}->0];
zeros=Position[Part[#,2]&/@mlist,x_/;x<=0];
zeros=DeleteCases[zeros,pos];
If[Position[zeros,{pos[[1]],_}]!={},Return[result]];
nonzeros=DeleteCases[Range[3],pos[[1]]];
nonzeros=Fold[DeleteCases[#1,#2[[1]]]&,nonzeros,zeros];
If[nonzeros=={},Return[result]];
If[!CCheckConv[c@@newmlist],
If[Count[Flatten[newmlist],x_/;x<0]>0||!CCheckConv[c@@{newmlist[[pos[[1]]]]}],Return[result]];
nonzeros=DeleteCases[nonzeros,_?(!CCheckConv[c@@{newmlist[[#]]}]&)];
If[nonzeros=={},Return[result]];
];
col1=pos[[1]];col2=nonzeros[[1]];result+=-Sum[c@@(MapAt[#-1&,newmlist,{col1,2,i}]),{i,1,Length[mlist[[col1,1]]]}];result+=+Sum[c@@(MapAt[#-1&,newmlist,{col2,2,i}]),{i,1,Length[mlist[[col2,1]]]}];Return[triSort[result]]];


triMomSimplify[lincomb_]:=FixedPoint[Block[{result=#},
result= result/.c[x_,y_,z_]/;Position[x[[2]],-1]!={}||Position[y[[2]],-1]!={}||Position[z[[2]],-1]!={}:>triMomentumCons[x,y,z];result= result/.(c[x_,y_,z_]/;Position[x[[1]],-1]!={}||Position[y[[1]],-1]!={}||Position[z[[1]],-1]!={}):>(triMomentumCons[Reverse[x],Reverse[y],Reverse[z]]/.{ba_c:>c@@(Reverse/@ba)});
Return[result]]&,lincomb];


TriHolMomConsId::divTriHolMomCons="Warning: You are generating the holomorphic momentum conservation identity from blocks `1` and `2` of the divergent graph `3`. Momentum conservation identities involving divergent subgraphs usually lead to inconsistencies!";
TriHolMomConsId::WrongBlockArg="The block argument `1` is not one of the admissible combinations {1,2}, {2,3} or {1,3}.";
TriHolMomConsId[c[x_List,y_List,z_List],blocks_List]:=Block[{ab={x,y,z},r=0,result=0, adBlocks={{1,2},{2,3},{1,3}}},
If[!MemberQ[adBlocks,Sort[blocks]],
Message[TriHolMomConsId::WrongBlockArg,blocks];
Return[c@@ab]
];
If[(Or@@(!CCheckConv[c[ab[[#]]]]&/@blocks))||Total[Min/@(Total/@(saveT[#])&/@ab)]<=2,Message[TriHolMomConsId::divTriHolMomCons,Sequence@@blocks,c@@ab];];
result=Sum[c@@MapAt[#-1&,ab,{blocks[[1]],1,i}],{i,1,Length[ab[[blocks[[1]],1]]]}]-Sum[c@@MapAt[#-1&,ab,{blocks[[2]],1,i}],{i,1,Length[ab[[blocks[[2]],1]]]}];Return[result==0]];

TriAHolMomConsId::divTriAHolMomCons="Warning: You are generating the antiholomorphic momentum conservation identity from blocks `1` and `2` of the divergent graph `3`. Momentum conservation identities involing divergent subgraphs usually lead to inconsistencies!";
TriAHolMomConsId::WrongBlockArg="The block argument `1` is not one of the admissible combinations {1,2}, {2,3} or {1,3}.";
TriAHolMomConsId[c[x_List,y_List,z_List],blocks_]:=Block[{ab={x,y,z},r=0,result=0, adBlocks={{1,2},{2,3},{1,3}}},
If[!MemberQ[adBlocks,Sort[blocks]],
Message[TriAHolMomConsId::WrongBlockArg,blocks];
Return[c@@ab]
];
If[(Or@@(!CCheckConv[c[ab[[#]]]]&/@blocks))||Total[Min/@(Total/@(saveT[#])&/@ab)]<=2,Message[TriAHolMomConsId::divTriAHolMomCons,Sequence@@blocks,c@@ab];];result=Sum[c@@MapAt[#-1&,ab,{blocks[[1]],2,i}],{i,1,Length[ab[[blocks[[1]],1]]]}]-Sum[c@@MapAt[#-1&,ab,{blocks[[2]],2,i}],{i,1,Length[ab[[blocks[[2]],1]]]}];Return[result==0]];


triFact::usage="Expects three matrices representing a trihedral MGF. Factorizes it if a zero column is present.";
triFact[mat1_,mat2_,mat3_]:=Block[{result=c[mat1,mat2,mat3],zerocol,col1,col2,shortColList,cc=0,n,mlist={mat1,mat2,mat3}},
zerocol=Position[saveT/@mlist,{0,0}];
If[zerocol=={},Return[result]];
mlist=MapAt[If[Length[#[[1]]]>=2,saveT[Delete[saveT[#],{zerocol[[1,2]]}]],{}]&,mlist,zerocol[[1,1]]];
zerocol=zerocol[[1,1]];
col1=Delete[Range[3],zerocol][[1]];
col2=Delete[Range[3],zerocol][[2]];
If[ContainsAny[saveT[mlist[[zerocol]]],{{1,0},{0,1}}],
messageOnce[cSimplifyWarnings,TriCSimplify::dangerousFact,triSort[c[mat1,mat2,mat3]]];
If[Count[saveT[mlist[[zerocol]]],{1,0}|{0,1}]>1,Return[c[mat1,mat2,mat3]]];
If[MemberQ[saveT[mlist[[zerocol]]],{0,1}],cc=1];(*If (0,1)-column use complex conjugated formula*)
shortColList=Delete[Range[Length[saveT[mlist[[zerocol]]]]],Position[saveT[mlist[[zerocol]]],{1,0}|{0,1}|{1,1}]];
n=Count[saveT[mlist[[zerocol]]],{1,1}];
result=-c@@mlist;
result+=(-1)^Total[mlist[[col2]],2] c[Join[mlist[[col1]],mlist[[col2]],2]](\[Pi]/tau[2])^(n+1) Sum[Product[c[{
 {mlist[[zerocol,1,j]]-cc  KroneckerDelta[i,j], 0},
 {mlist[[zerocol,2,j]]-(1-cc)KroneckerDelta[i,j], 0}
}],{j,shortColList}],{i,shortColList}]Sum[(-1)^(k+1) n!/(n-k)! e[1]^(n-k),{k,0,n}];
,
result=(-1)^Total[mlist[[col2]],2] c[Join[mlist[[col1]],mlist[[col2]],2]]Product[c[{{mlist[[zerocol,1,r]],0},{mlist[[zerocol,2,r]],0}}],{r,1,If[mlist[[zerocol]]=={},0,Length[mlist[[zerocol,1]]]]}]-c@@mlist;
];
result=result/.c[x_,y_,z_]/;x=={}||y=={}||z=={}:>c[x]c[y]c[z]/.c[{}]->1;Return[triSort[result]]];


triExplicitIdentities::usage="Explicitly known identities for trihedral MGFs";
triExplicitIdentities=If[FileExistsQ[packageDir<>"TriIds.txt"],Get[packageDir<>"TriIds.txt"],{}];
Print["Loaded "<>ToString[Length[triExplicitIdentities]]<>" identities for trihedral MGFs."];


Options[triLimCSimplify]={momSimplify->True};
TriCSimplify::wrongArgMomSimplify="Wrong argument \"`1`\" for momSimplify: Allowed are only True and False.";
TriCSimplify::dangerousFact="The graph `1` is factorized and contains a (1,0) or (0,1) column in the same block as the (0,0) column. This may be problematic.";
triLimCSimplify[exp_,opts:OptionsPattern[]]:=Block[{result=exp},
If[ContainsNone[{True,False},{OptionValue[momSimplify]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongArgMomSimplify,OptionValue[momSimplify]];
Return[exp]];
result=result/.c[x_,y_,z_]/;OddQ[Total[Flatten[{x,y,z}]]]->0;
result=result/.c[x_,y_,z_]/;MemberQ[{x,y,z},{}]:>c[x]c[y]c[z]/.c[{}]->1;
result=result/.c[x_,y_,z_]/;Count[Dimensions/@{x,y,z},{2,1}]>=2:>triRed[x,y,z];
result=result/.c[x_,y_,z_]/;MemberQ[Flatten[saveT/@{x,y,z},1],{0,0}]:>triFact[x,y,z];
If[OptionValue[momSimplify],result=triMomSimplify[result]];
result=triSort[result];
Return[Expand[result]]];
Options[TriLimCSimplify]=Options[triLimCSimplify];
TriLimCSimplify[exp_,opts:OptionsPattern[]]:=FixedPoint[triLimCSimplify[#,opts]&,exp];


triHolSubRed2pt::usage="Expects three matrices representing a trihedral MGF and tries to perform holomorphic subgraph reduction on a two-valent holomorphic subgraph.";
Options[triHolSubRed2pt]={divHSR->True,triDivHSR->True};
TriCSimplify::wrongDivHSRArg="Wrong argument \"`1`\" for divHSR: Allowed are only True and False.";
TriCSimplify::wrongTriDivHSRArg="Wrong argument \"`1`\" for triDivHSR: Allowed are only True and False.";
TriCSimplify::divHSRNotPossible="Encountered the divergent HSR-graph `1` but divergent HSR is deactivated.";
triHolSubRed2pt[m1_,m2_,m3_,opts:OptionsPattern[]]:=Block[{mlist={m1,m2,m3},zeroblock,goodblock,a1,a2,apos,avals,abMat,result=0,cdummy},
If[OddQ[Total[Flatten[mlist]]],Return[0]];
If[MemberQ[mlist,{}],Return[c@@mlist]];
If[MemberQ[Flatten[saveT/@mlist,1],{0,0}],Return[c@@mlist]];
If[Count[Dimensions/@mlist,{2,1}]>=2,Return[c@@mlist]];
If[ContainsNone[{True,False},{OptionValue[divHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongDivHSRArg,OptionValue[divHSR]];Return[c[m1,m2,m3]]];
If[ContainsNone[{True,False},{OptionValue[triDivHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongTriDivHSRArg,OptionValue[triDivHSR]];Return[c[m1,m2,m3]]];
If[(!OptionValue[divHSR]||!OptionValue[triDivHSR])&&!CCheckConv[c@@mlist],messageOnce[cSimplifyWarnings,TriCSimplify::divHSRNotPossible,triSort[c@@mlist]];Return[c@@mlist]];
apos=Position[#[[2]],0]&/@mlist;(*positions of a
0

 columns*)
avals=(mlist[[#,1,Flatten[apos[[#]]]]]&)/@{1,2,3};(*values of the a in those columns*)
apos=MapIndexed[(If[avals[[Sequence@@#2]]<=0,Nothing,#1]&),apos,{2}];(*Delete positions and values if a is \[LessEqual]0*)
avals=DeleteCases[avals,x_/;x<=0,{2}];
zeroblock=Flatten[Position[Length/@apos,x_/;x>=2]];(*zeroblock: blocks with two or more zeros in the second row*)
If[zeroblock=={},Return[c@@mlist]];
If[Length[zeroblock]>1&&DeleteCases[zeroblock,_?(!CCheckConv[c[mlist[[#]]]]&)]!={},(*if there is more than one zeroblock and at least one convergent one*)
zeroblock=DeleteCases[zeroblock,_?(!CCheckConv[c[mlist[[#]]]]&)][[1]];,(*select the first convergent zeroblock*)
zeroblock=zeroblock[[1]];(*else: select first zeroblock*)
];(*i.e. this selects convergent blocks if possible*)
a1=mlist[[zeroblock,1,apos[[zeroblock,1]]]]/.List->Identity;(*select first two a
0

 colmuns in the selected zeroblock*)
a2=mlist[[zeroblock,1,apos[[zeroblock,2]]]]/.List->Identity;
If[a1==a2==1,
abMat=If[Dimensions[mlist[[zeroblock]]]=={2,2},{},saveT[Delete[saveT[mlist[[zeroblock]]],{apos[[zeroblock,1]],apos[[zeroblock,2]]}]]];
cdummy=c@@MapAt[prepCol[{a,b},abMat]&,mlist,zeroblock];
result=- 2(cdummy/.{a->2,b->0})+\[Pi]/tau[2] (cdummy/.{a->1,b->-1})-gHat[2](c@@MapAt[abMat&,mlist,zeroblock]);
result=result/.c[x_,y_,z_]/;x=={}||y=={}||z=={}:>c[x]c[y]c[z]/.c[{}]->1;
Return[triSort[result]];
];
abMat=If[Dimensions[mlist[[zeroblock]]]=={2,2},{},saveT[Delete[saveT[mlist[[zeroblock]]],{apos[[zeroblock,1]],apos[[zeroblock,2]]}]]];cdummy=c@@MapAt[prepCol[{a,b},abMat]&,mlist,zeroblock];result=-Binomial[a1+a2,a1](cdummy/.{a->a1+a2,b->0});
result+=Binomial[a1+a2-2,a1-1](gHat[2](cdummy/.{a->a1+a2-2,b->0})+\[Pi]/tau[2] (cdummy/.{a->a1+a2-1,b->-1}));
result+=Sum[Binomial[a1+a2-k-1,a1-k]g[k](cdummy/.{a->a1+a2-k,b->0}),{k,4,a1}];
result+=Sum[Binomial[a1+a2-k-1,a2-k]g[k](cdummy/.{a->a1+a2-k,b->0}),{k,4,a2}];
result+=c[{
 {a1, a2},
 {0, 0}
}](c@@MapAt[abMat&,mlist,zeroblock]);
result=result/.c[x_,y_,z_]/;x=={}||y=={}||z=={}:>c[x]c[y]c[z]/.c[{}]->1;
Return[triSort[result]];
];


triHolSubRed3ptFay::usage="Expects three matrices representing a trihedral MGF and tries to preform holomorphic subgraph reduction on a three-valent holomorphic subgraph by employing Fay identities.";

Options[triHolSubRed3ptFay]={divHSR->True,triDivHSR->True};

TriCSimplify::div3ptFay="You are generating the 3pt HSR of the divergent graph `1` via Fay identities. There are known cases in which this leads to contradictions.";

triHolSubRed3ptFay[m1_,m2_,m3_,opts:OptionsPattern[]]:=Block[{mlist={m1,m2,m3},apos,result},
If[ContainsNone[{True,False},{OptionValue[divHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongDivHSRArg,OptionValue[divHSR]];Return[c[m1,m2,m3]]];
If[ContainsNone[{True,False},{OptionValue[triDivHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongTriDivHSRArg,OptionValue[triDivHSR]];Return[c[m1,m2,m3]]];
If[OddQ[Total[Flatten[mlist]]],Return[0]];
If[MemberQ[mlist,{}],Return[c@@mlist]];
If[MemberQ[Flatten[saveT/@mlist,1],{0,0}],Return[c@@mlist]];
If[Count[Dimensions/@mlist,{2,1}]>=2,Return[c@@mlist]];
If[Or@@(Count[#,0]==0&/@mlist[[All,2]]),Return[c[m1,m2,m3]]];(*if there is a block with no 0 in the second row, return input*)
If[(!CCheckConv[c@@mlist])&&(!OptionValue[divHSR]||!OptionValue[triDivHSR]),messageOnce[cSimplifyWarnings,TriCSimplify::divHSRNotPossible,triSort[c@@mlist]];Return[c@@mlist]];

apos=Position[mlist[[All,2]],0];
apos=If[mlist[[#[[1]],1,#[[2]]]]<0,Nothing,#]&/@apos;(*Delete a
0

 columns with a<0*)
If[!DuplicateFreeQ[First/@apos],Return[c@@mlist]];(*if a block appears twice, one can do 2pt HSR, so return the input*)
If[Length[apos]<3,Return[c@@mlist]];(*If less than three blocks remain, one cannot do 3pt HSR*)

If[!CCheckConv[c@@mlist],messageOnce[cSimplifyWarnings,TriCSimplify::div3ptFay,triSort[c@@mlist]]];
result=TriFay[c@@mlist,Delete[apos,1]][[2]];
Return[result]];


triHolSubRed3pt::usage="Expects three matrices representing a trihedral MGF and tries to preform holomorphic subgraph reduction on a three-valent holomorphic subgraph.";
Options[triHolSubRed3pt]={divHSR->True,triDivHSR->True,tri2ptHSR->True};
TriCSimplify::noConvHSROrder="No ordering of the blocks of `1` is suitable for convergent three-point HSR.";
triHolSubRed3pt[m1_,m2_,m3_,opts:OptionsPattern[]]:=Block[{mlist=(saveT[Sort[saveT[#]]]&/@{m1,m2,m3}),troubleblocks,goodblock,a,a1,a2,a3,apos,divblock,abMat,c2132,c2131,c2121,c21,c32,result=0},
If[ContainsNone[{True,False},{OptionValue[divHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongDivHSRArg,OptionValue[divHSR]];Return[c[m1,m2,m3]]];
If[ContainsNone[{True,False},{OptionValue[triDivHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongTriDivHSRArg,OptionValue[triDivHSR]];Return[c[m1,m2,m3]]];
If[(!OptionValue[divHSR]||!OptionValue[triDivHSR])&&!CCheckConv[c@@mlist],messageOnce[cSimplifyWarnings,TriCSimplify::divHSRNotPossible,triSort[c@@mlist]];Return[c@@mlist]];
If[OddQ[Total[Flatten[mlist]]],Return[0]];
If[MemberQ[mlist,{}],Return[c@@mlist]];
If[MemberQ[Flatten[saveT/@mlist,1],{0,0}],Return[c@@mlist]];
If[Count[Dimensions/@mlist,{2,1}]>=2,Return[c@@mlist]];
If[Or@@(Count[#,0]==0&/@mlist[[All,2]]),Return[c[m1,m2,m3]]];(*if there is a block with no 0 in the second row, return input*)

troubleblocks=If[!CCheckConv[c[m1,m2,m3]],
(ContainsAll[saveT[#],{{0,1},{1,0}}]||ContainsAll[saveT[#],{{1,1},{1,0}}])&/@mlist,(*if the MGF is divergent, the last block shouldn\[CloseCurlyQuote]t contain a 1	0
0	1

 block to avoid problems due to divergent seeds when removing the -1 and no 1	1
0	1

 block to avoid an undecomposable 1	1
0	0

 block*)
(ContainsAll[saveT[#],{{1,1},{1,0}}])&/@mlist]; (*if the MGF is convergent, the last block shouldn\[CloseCurlyQuote]t contain a 1	1
0	1

 block to avoid divergent graphs in the output*)
If[(And@@troubleblocks),
messageOnce[cSimplifyWarnings,TriCSimplify::noConvHSROrder,triSort[c@@mlist]];
If[OptionValue[divHSR]&&OptionValue[triDivHSR],goodblock=1,

Return[c[m1,m2,m3]]],
goodblock=First[Flatten[Position[troubleblocks,False]]];
];
mlist=Join[Delete[mlist,goodblock],{mlist[[goodblock]]}];(*this brings the first good block into the last block*)

apos=Position[mlist[[All,2]],0];
apos=If[mlist[[#[[1]],1,#[[2]]]]<0,Nothing,#]&/@apos;(*Delete a
0

 columns with a<0*)
If[!DuplicateFreeQ[First/@apos]&&OptionValue[tri2ptHSR],Return[c@@mlist]];(*if a block appears twice, one can do 2pt HSR, so return the input*)
apos=DeleteDuplicatesBy[apos,First];
If[Length[apos]<3,Return[c@@mlist]];(*If less than three blocks remain, one cannot do 3pt HSR*)
a=mlist[[#[[1]],1,#[[2]]]]&/@apos;

abMat=If[Length[mlist[[#[[1]]]]]==1,{},saveT[Delete[saveT[mlist[[#[[1]]]]],#[[2]]]]]&/@apos;
c2131=(c@@{abMat[[1]],prepCol[{p21,pb21},abMat[[2]]],prepCol[{p31,pb31},abMat[[3]]]})-(-1)^(p21+pb21+p31+pb31) (c@@MapAt[prepCol[{p21+p31,pb21+pb31},#]&,abMat,1]);c2132=(-1)^(p21+pb21) (c@@{prepCol[{p21,pb21},abMat[[1]]],abMat[[2]],prepCol[{p32,pb32},abMat[[3]]]})-(-1)^(p32+pb32) (c@@MapAt[prepCol[{p21+p32,pb21+pb32},#]&,abMat,2]);c2121=c@@MapAt[prepCol[{p21,pb21},#]&,abMat,2];c21=(-1)^(p21+pb21) (c@@MapAt[prepCol[{p21,pb21},#]&,abMat,1]);c32=c@@MapAt[prepCol[{p32,pb32},#]&,abMat,3];a1=a[[1]];a2=a[[2]];a3=a[[3]];
(*Subscript[L, 1]*)
result=g[Total[a]]c@@abMat;
(*Subscript[L, 2]*)result+=(-1)^(a1+a2) (-(c32/.{pb32->0,p32->a1+a2+a3}) Binomial[a1+a2+a3,a1+a2]+\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(k = 4\), \(a1 + a2\)]\(\((c32 /. {pb32 -> 0, p32 -> a1 + a2 + a3 - k})\)\ Binomial[\(-1\) + a1 + a2 + a3 - k, a1 + a2 - k]\ g[k]\)\)+\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(k = 4\), \(a3\)]\(\((c32 /. {pb32 -> 0, p32 -> a1 + a2 + a3 - k})\) Binomial[\(-1\) + a1 + a2 + a3 - k, a3 - k]\ g[k]\)\)+Binomial[-2+a1+a2+a3,-1+a1+a2] (\[Pi]/tau[2] (c32/.{pb32->-1,p32->a1+a2+a3-1})+(c32/.{pb32->0,p32->a1+a2+a3-2}) gHat[2]));
(*Subscript[L, 3]*)result+=(-1)^a1 (- (c21/.{pb21->0,p21->a1+a2+a3})Binomial[a1+a2+a3,a1]+\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(k = 4\), \(a1\)]\(\((c21 /. {pb21 -> 0, p21 -> a1 + a2 + a3 - k})\) Binomial[\(-1\) + a1 + a2 + a3 - k, a1 - k]\ g[k]\)\)+\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(k = 4\), \(a2 + a3\)]\(\((c21 /. {pb21 -> 0, p21 -> a1 + a2 + a3 - k})\) Binomial[\(-1\) + a1 + a2 + a3 - k, a2 + a3 - k]\ g[k]\)\)+Binomial[-2+a1+a2+a3,-1+a1] (\[Pi]/tau[2] (c21/.{pb21->-1,p21->a1+a2+a3-1})+(c21/.{pb21->0,p21->a1+a2+a3-2}) gHat[2]));
(*Subscript[L, 4]*)result+=(-1)^(a1+a3) (-(c2121/.{pb21->0,p21->a1+a2+a3}) Binomial[a1+a2+a3,a1+a3]+\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(k = 4\), \(a2\)]\(\((c2121 /. {pb21 -> 0, p21 -> a1 + a2 + a3 - k})\)\ Binomial[\(-1\) + a1 + a2 + a3 - k, a2 - k]\ g[k]\)\)+\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(k = 4\), \(a1 + a3\)]\(\((c2121 /. {pb21 -> 0, p21 -> a1 + a2 + a3 - k})\) Binomial[\(-1\) + a1 + a2 + a3 - k, a1 + a3 - k]\ g[k]\)\)+Binomial[-2+a1+a2+a3,-1+a1+a3] (\[Pi]/tau[2] (c2121/.{pb21->-1,p21->a1+a2+a3-1})+(c2121/.{pb21->0,p21->a1+a2+a3-2})gHat[2]));
(*Subscript[L, 5], but not the version in 1809.05122*)
result+=(+(-1)^(a1+1)Sum[Binomial[a1+a2-k-1,a1-k]Binomial[a3+k-1,k] (k a2+a3 a2+a1 a3-k a3)/(a3 a2) (c2131/.{pb21->0,pb31->0,p21->a1+a2-k,p31->a3+k}),{k,1,a1}]+(-1)^(a1+1) Binomial[-1+a1+a2,a2](c2131/.{pb21->0,pb31->0,p21->a1+a2,p31->a3})+(-1)^a1 Sum[Binomial[a1+a2-k-1,a2-k]Binomial[a3+k-1,k] (k a3-k a1-a1 a3-a2 a3)/(a3 a1) (-1)^k (c2132/.{pb21->0,pb32->0,p21->a1+a2-k,p32->a3+k}),{k,1,a2}]+(-1)^(a1+1) Binomial[a1+a2-1,a1](c2132/.{pb21->0,pb32->0,p21->a1+a2,p32->a3})+(-1)^(a1+1) Sum[Binomial[k+a3-m-1,l-m]Binomial[a1+a2-k-1,a1-k]Binomial[k+a3-l-1,a3-l](-1)^(m+l) (c2132/.{pb21->0,pb32->0,p21->a1+a2+a3-m,p32->m}),{k,1,a1},{l,1,a3},{m,1,l}]+(-1)^(a1+1) Sum[Binomial[k+a3-m-1,l-1]Binomial[a1+a2-k-1,a1-k]Binomial[k+a3-l-1,a3-l](-1)^l (c2131/.{pb21->0,pb31->0,p21->a1+a2+a3-m,p31->m}),{k,1,a1},{l,1,a3},{m,1,k+a3-l}]+(-1)^(a1+1) Sum[Binomial[k+a3-m-1,l-1]Binomial[a1+a2-k-1,a2-k]Binomial[k+a3-l-1,a3-l](-1)^(m+l+a3) (c2132/.{pb21->0,pb32->0,p21->a1+a2+a3-m,p32->m}),{k,1,a2},{l,1,a3},{m,1,k+a3-l}]+(-1)^(a1+1) Sum[Binomial[k+a3-m-1,l-m]Binomial[a1+a2-k-1,a2-k]Binomial[k+a3-l-1,a3-l](-1)^(a3+l) (c2131/.{pb21->0,pb31->0,p21->a1+a2+a3-m,p31->m}),{k,1,a2},{l,1,a3},{m,1,l}]);result+=(-1)^a1 Sum[Binomial[a1+a2-k-1,a1-k]Binomial[a3+k-2,a3-1](gHat[2](c2131/.{pb21->0,pb31->0,p21->a1+a2-k,p31->a3+k-2})+\[Pi]/tau[2] (c2131/.{pb21->0,pb31->-1,p21->a1+a2-k,p31->a3+k-1})),{k,1,a1}]+(-1)^a1 Sum[Binomial[a1+a2-k-1,a2-k]Binomial[a3+k-2,a3-1](-1)^k (gHat[2](c2132/.{pb21->0,pb32->0,p21->a1+a2-k,p32->a3+k-2})+\[Pi]/tau[2] (c2132/.{pb21->0,pb32->-1,p21->a1+a2-k,p32->a3+k-1})),{k,1,a2}];result+=(-1)^a1 Sum[Binomial[a1+a2-k-1,a1-k]Binomial[k+a3-l-1,k-l]g[l](c2131/.{pb21->0,pb31->0,p21->a1+a2-k,p31->a3+k-l}),{k,4,a1},{l,4,k}]+(-1)^a1 Sum[Binomial[a1+a2-k-1,a1-k]Binomial[k+a3-l-1,a3-l]g[l](c2131/.{pb21->0,pb31->0,p21->a1+a2-k,p31->a3+k-l}),{k,1,a1},{l,4,a3}]+(-1)^a1 Sum[Binomial[a1+a2-k-1,a2-k]Binomial[k+a3-l-1,k-l](-1)^k g[l](c2132/.{pb21->0,pb32->0,p21->a1+a2-k,p32->a3+k-l}),{k,4,a2},{l,4,k}]+(-1)^a1 Sum[Binomial[a1+a2-k-1,a2-k]Binomial[k+a3-l-1,a3-l](-1)^k g[l](c2132/.{pb21->0,pb32->0,p21->a1+a2-k,p32->a3+k-l}),{k,1,a2},{l,4,a3}];
result=result/.c[x_,y_,z_]/;x=={}||y=={}||z=={}:>c[x]c[y]c[z]/.c[{}]->1;
Return[triSort[result]]];


TriFay::wrongPosArg="Wrong argument for Fay positions: Expect an argument of the form {{b1,c1},{b2,c2}} where c1 is the column number in the b1 block and c2 the column number in the b2 block. The columns have to be in different blocks and should both be of the form (n,0) or (0,n) with n\[GreaterEqual]1.";
TriFay::noFayCols="No suitable columns for Fay identities were found";
TriFay[c[m1_,m2_,m3_],posarg_:{}]:=Block[{m={m1,m2,m3},mnew,n,n1,n2,col1,col2,col3,result,pos},
If[posarg=={},
pos=DeleteDuplicates[Position[m[[All,2]],0],(First[#1]==First[#2]&)];
If[Length[pos]>=2,
pos=pos[[1;;2]];,
pos=DeleteDuplicates[Position[m[[All,1]],0],(First[#1]==First[#2]&)];
If[Length[pos]>=2,
pos=pos[[1;;2]];,
Message[TriFay::noFayCols];
Return[c@@m];
];
];,
pos=posarg;
];
If[!MatchQ[pos,{{b1_,_},{b2_,_}}/;MemberQ[{1,2,3},b1]&&MemberQ[{1,2,3},b2]]||pos[[1,2]]>Length[m[[pos[[1,1]],1]]]||pos[[2,2]]>Length[m[[pos[[2,1]],1]]],
Message[TriFay::wrongPosArg];Return[c@@m];
];
col1=pos[[1,1]];
col2=pos[[2,1]];
n=(c@@(saveT/@m))[[Sequence@@(#)]]&/@pos;
If[col1==col2||!MatchQ[n,{{k_,0},{l_,0}}|{{0,k_},{0,l_}}/;k>0&&l>0],
Message[TriFay::wrongPosArg];Return[c@@m];
];
n1=Total[n[[1]]];
n2=Total[n[[2]]];
col3=6-col1-col2;
If[n[[1,1]]==0,m={Reverse[m1],Reverse[m2],Reverse[m3]}];
mnew=saveT/@Delete[saveT/@m,{pos[[1]],pos[[2]]}];
result=(c@@m==((-1)^(n1+n2) c@@MapAt[prepCol[{n1+n2,0},#]&,mnew,col3]+(-1)^n2 \!\(
\*SubsuperscriptBox[\(\[Sum]\), \(j = 0\), \(n2 - 1\)]\(Binomial[n1 - 1 + j, j] c @@ MapAt[prepCol[{n1 + j, 0}, #] &, MapAt[prepCol[{n2 - j, 0}, #] &, mnew, col3], col1]\)\)+(-1)^(n2+1) Binomial[n1+n2-1,n2]c@@MapAt[prepCol[{n1+n2,0},#]&,mnew,col1]+(-1)^n1 \!\(
\*SubsuperscriptBox[\(\[Sum]\), \(j = 0\), \(n1 - 1\)]\(Binomial[n2 - 1 + j, j] c @@ MapAt[prepCol[{n1 - j, 0}, #] &, MapAt[prepCol[{n2 + j, 0}, #] &, mnew, col2], col3]\)\)+(-1)^(n1+1) Binomial[n1+n2-1,n1]c@@MapAt[prepCol[{n1+n2,0},#]&,mnew,col2]));
If[n[[1,1]]==0,result=CComplexConj[result]];
Return[triSort[result]]];


Options[triCSimplify]=DeleteDuplicates[Join[{useIds->True,triHSR->True,tri2ptHSR->True,tri3ptHSR->True,tri3ptFayHSR->False},Options[triHolSubRed2pt],Options[triHolSubRed3pt],Options[triHolSubRed3ptFay],Options[TriLimCSimplify]]];
TriCSimplify::wrongUseIdsArg="Wrong argument \"`1`\" for useIDs: Allowed are only True and False.";
TriCSimplify::wrongTri3ptFayHSRArg="Wrong argument \"`1`\" for tri3ptFayHSR: Allowed are only True and False.";
TriCSimplify::wrongTriHSRArg="Wrong argument \"`1`\" for triHSR: Allowed are only True and False.";
TriCSimplify::wrongTri2ptHSRArg="Wrong argument \"`1`\" for tri2ptHSR: Allowed are only True and False.";
TriCSimplify::wrongTri3ptHSRArg="Wrong argument \"`1`\" for tri3ptHSR: Allowed are only True and False.";
triCSimplify[lincomb_,opts:OptionsPattern[]]:=Block[{result=lincomb},
If[ContainsNone[{True,False},{OptionValue[useIds]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongUseIdsArg,OptionValue[useIds]];Return[lincomb]];
If[ContainsNone[{True,False},{OptionValue[triHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongTriHSRArg,OptionValue[triHSR]];Return[lincomb]];
If[ContainsNone[{True,False},{OptionValue[tri2ptHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongTri2ptHSRArg,OptionValue[tri2ptHSR]];Return[lincomb]];
If[ContainsNone[{True,False},{OptionValue[tri3ptHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongTri3ptHSRArg,OptionValue[tri3ptHSR]];Return[lincomb]];
If[ContainsNone[{True,False},{OptionValue[tri3ptFayHSR]}],messageOnce[cSimplifyWarnings,TriCSimplify::wrongTri3ptFayHSRArg,OptionValue[tri3ptHSR]];Return[lincomb]];
If[OptionValue[triHSR],
If[OptionValue[tri2ptHSR],
result=result/.c[x_,y_,z_]/;(If[x=={},False,Count[x[[2]],0]>=2]||If[y=={},False,Count[y[[2]],0]>=2]||If[z=={},False,Count[z[[2]],0]>=2]):>triHolSubRed2pt[x,y,z,FilterRules[{opts}, Options[triHolSubRed2pt]]];
result=result/.c[x_,y_,z_]/;(If[x=={},False,Count[x[[1]],0]>=2]||If[y=={},False,Count[y[[1]],0]>=2]||If[z=={},False,Count[z[[1]],0]>=2]):>CComplexConj[triHolSubRed2pt[Reverse[x],Reverse[y],Reverse[z],FilterRules[{opts}, Options[triHolSubRed2pt]]]];
];
If[OptionValue[tri3ptHSR]&&!OptionValue[tri3ptFayHSR],
result=result/.c[x_,y_,z_]/;x!={}&&y!={}&&z!={}&&Count[x[[2]],0]>=1&&Count[y[[2]],0]>=1&&Count[z[[2]],0]>=1:>triHolSubRed3pt[x,y,z,FilterRules[{opts}, Options[triHolSubRed3pt]]];
result=result/.c[x_,y_,z_]/;x!={}&&y!={}&&z!={}&&Count[x[[1]],0]>=1&&Count[y[[1]],0]>=1&&Count[z[[1]],0]>=1:>CComplexConj[triHolSubRed3pt[Reverse[x],Reverse[y],Reverse[z],FilterRules[{opts}, Options[triHolSubRed3pt]]]];
];
If[OptionValue[tri3ptHSR]&&OptionValue[tri3ptFayHSR],
result=result/.c[x_,y_,z_]/;x!={}&&y!={}&&z!={}&&Count[x[[2]],0]>=1&&Count[y[[2]],0]>=1&&Count[z[[2]],0]>=1:>triHolSubRed3ptFay[x,y,z,FilterRules[{opts}, Options[triHolSubRed3ptFay]]];
result=result/.c[x_,y_,z_]/;x!={}&&y!={}&&z!={}&&Count[x[[1]],0]>=1&&Count[y[[1]],0]>=1&&Count[z[[1]],0]>=1:>CComplexConj[triHolSubRed3ptFay[Reverse[x],Reverse[y],Reverse[z],FilterRules[{opts}, Options[triHolSubRed3ptFay]]]];
];
];
result=TriLimCSimplify[result,FilterRules[{opts},Options[TriLimCSimplify]]];
If[OptionValue[useIds],result=result/.c[x_,y_,z_]:>(c[x,y,z]/.triExplicitIdentities)];
Return[result]];
Options[TriCSimplify]=Options[triCSimplify];
TriCSimplify[exp_,opts:OptionsPattern[]]:=(If[!insideCSimplify,cSimplifyWarnings={}];FixedPoint[triCSimplify[#,opts]&,exp]);


tetS4Orbit::usage="Expects six matrices corresponding to a tetrahedral MGF and returns a list of 24 equivalent representations, corresponding to the complete \!\(\*SubscriptBox[\(S\), \(4\)]\) orbit or relabeling the vertices.";
tetS4Orbit[ab1_,ab2_,ab3_,ab4_,ab5_,ab6_]:=Block[{tetperms,p,result},
tetperms=({#[[1]]->#[[2]],#[[4]]->#[[2]],#[[3]]->#[[2]],#[[4]]->#[[3]],#[[3]]->#[[1]],#[[1]]->#[[4]]})&/@Permutations[Range[4]];
tetperms=tetperms/.{(1->2)->p[1],(2->1)->(-1)^a[1] p[1],(4->2)->p[2],(2->4)->(-1)^a[2] p[2],(3->2)->p[3],(2->3)->(-1)^a[3] p[3],(4->3)->p[4],(3->4)->(-1)^a[4] p[4],(3->1)->p[5],(1->3)->(-1)^a[5] p[5],(1->4)->p[6],(4->1)->(-1)^a[6] p[6]};
tetperms=tetperms/.{{(is:(-1)^a[_]:1)p[i_],(js:(-1)^a[_]:1)p[j_],(ks:(-1)^a[_]:1)p[k_],(ls:(-1)^a[_]:1)p[l_],(ms:(-1)^a[_]:1)p[m_],(ns:(-1)^a[_]:1)p[n_]}:>{is js ks ls ms ns,{p[i],p[j],p[k],p[l],p[m],p[n]}}}/.p->Identity;
result=((#[[1]]/.a[k_]:>Total[{{ab1,ab2,ab3,ab4,ab5,ab6}[[k]]},-1])c@@Permute[{ab1,ab2,ab3,ab4,ab5,ab6},InversePermutation[#[[2]]]]&/@tetperms);

Return[result]];


tetKiteOrbit::usage="Expects five matrices corresponding to a kite MGF and returns a list of 8 equivalent representations, corresponding to the symmetry orbit or relabeling the vertices.";
tetKiteOrbit[ab1_,ab2_,ab3_,ab4_,ab5_]:={c[ab1,ab2,ab3,ab4,ab5],c[ab1,ab2,ab4,ab3,ab5],c[ab2,ab1,ab3,ab4,ab5],c[ab2,ab1,ab4,ab3,ab5],c[ab3,ab4,ab1,ab2,ab5],c[ab3,ab4,ab2,ab1,ab5],c[ab4,ab3,ab1,ab2,ab5],c[ab4,ab3,ab2,ab1,ab5]};


tetSort::usage="Sorts four-point graphs into their canonical representation.";
tetSort[exp_]:=exp/.{c[ab1_,ab2_,ab3_,ab4_,ab5_,ab6_]:>First[Sort[tetS4Orbit@@(If[#==={},{},saveT[Sort[saveT[#]]]]&/@{ab1,ab2,ab3,ab4,ab5,ab6})]],
c[ab1_,ab2_,ab3_,ab4_,ab5_]:>First[Sort[tetKiteOrbit@@(saveT[Sort[saveT[#]]]&/@{ab1,ab2,ab3,ab4,ab5})]],
c[ab1_,ab2_,ab3_,ab4_]:>Sort[c@@(saveT[Sort[saveT[#]]]&/@{ab1,ab2,ab3,ab4})]};


(*generate conditions, under which tetrahedral MGFs vanish by symmetry, with dummy variables ab[1]...ab[6] for the six blocks*)
tetSymVanConds=Block[{sympairs,signconds,blockconds,result},
sympairs=Subsets[tetS4Orbit@@Array[ab,6],{2}];
blockconds=And@@@(MapThread[Equal,#]&/@(sympairs/.(-1)->1/.c[x__]:>List[x]));
signconds=Unequal@@@(sympairs/.c[__]->1/.ab[k_]:>Hold[Total[ab[k],2]]);
result=Inner[And,signconds,blockconds,Or];
result];


tetTopSimplify::usage="Apply topological simplifications for four-point graphs: From tetrahedral to kite, from kite to box and from box to trihedral.";
tetTopSimplify[exp_]:=Block[{result=tetSort[exp]},
result=result/.{c[{},ab2_,ab3_,ab4_,ab5_,ab6_]:>tetSort[(-1)^(Total[ab4,2]+Total[ab2,2]) c[ab2,ab3,ab5,ab6,ab4]]};
result=result/.{
c[{},ab2_,ab3_,ab4_,ab5_]:>tetSort[(-1)^Total[ab5,2] c[ab2]c[ab3,ab4,ab5]],
c[ab1_,ab2_,ab3_,ab4_,{}]:>tetSort[(-1)^(Total[ab3,2]+Total[ab4,2]) c[ab1,ab2,ab3,ab4]],
c[ab1_,ab2_,ab3_,ab4_,ab5_]/;(Length/@({ab1,ab2}[[All,1]]))=={1,1}:>tetSort[(-1)^(Total[ab3,2]+Total[ab4,2]) c[Join[ab1+ab2,ab5,2],ab3,ab4]]};
result=result/.{
c[{},ab1_,ab2_,ab3_]:>tetSort[c[ab1]c[ab2]c[ab3]],
c[ab1_,ab2_,ab3_,ab4_]/;(Length/@({ab1,ab2}[[All,1]]))=={1,1}:>tetSort[c[ab1+ab2,ab3,ab4]]
};
result=result/.c[{}]->1;
Return[result]];


Options[tetLimCSimplify]:={};
tetLimCSimplify[lincomb_,opts:OptionsPattern[]]:=Block[{result=(tetSort[lincomb])},
result=result/.c[ab1_,ab2_,ab3_,ab4_,ab5_,ab6_]/;OddQ[Total[{ab1,ab2,ab3,ab4,ab5,ab6},-1]]->0;
result=result/.c[ab1_,ab2_,ab3_,ab4_,ab5_]/;OddQ[Total[{ab1,ab2,ab3,ab4,ab5},-1]]->0;
result=result/.c[ab1_,ab2_,ab3_,ab4_]/;OddQ[Total[{ab1,ab2,ab3,ab4},-1]]->0;
result=tetTopSimplify[result];
result=result/.c[ab1_,ab2_,ab3_,ab4_,ab5_,ab6_]/;ReleaseHold[tetSymVanConds/.{ab[1]->ab1,ab[2]->ab2,ab[3]->ab3,ab[4]->ab4,ab[5]->ab5,ab[6]->ab6}]->0;
Return[Expand[tetSort[result]]]]
Options[TetLimCSimplify]=Options[tetLimCSimplify];
TetLimCSimplify[exp_,opts:OptionsPattern[]]:=FixedPoint[tetLimCSimplify[#,opts]&,exp];


Options[tetCSimplify]=Join[{},Options[TetLimCSimplify]];
tetCSimplify[lincomb_,opts:OptionsPattern[]]:=Block[{result=lincomb},
result=TetLimCSimplify[result,FilterRules[{opts},Options[TetLimCSimplify]]];
Return[result]];
Options[TetCSimplify]=Options[tetCSimplify];
TetCSimplify[exp_,opts:OptionsPattern[]]:=(If[!insideCSimplify,cSimplifyWarnings={}];FixedPoint[tetCSimplify[#,opts]&,exp]);


CSort[exp_]:=exp/.c[ab_]:>c[saveT[Sort[saveT[ab]]]]/.c[ab_]/;Dimensions[ab]=={2,2}:>(-1)^Total[ab[[All,2]]] c[{
 {ab[[1,1]]+ab[[1,2]], 0},
 {ab[[2,1]]+ab[[2,2]], 0}
}]//triSort//tetSort;


CComplexConj[exp_]:=exp/.{ba_c:>c@@(Reverse/@ba),ab_a:>-a@@ab,g[k_]:>gBar[k],gHat[2]->gBarHat[2],ab_intConst:>If[CSort[c@@(Reverse/@ab)]===c@@ab,intConst@@ab,intConstBar@@ab],gBar[k_]:>g[k],gBarHat[2]->gHat[2],intConstBar[x__]:>intConst[x],nablaE[n_,k_]:>nablaBarE[n,k],nablaBarE[n_,k_]:>nablaE[n,k],nablaEp[n_,k_]:>nablaBarEp[n,k],nablaBarE[n_,k_]:>nablaE[n,k],b[2,3]->-b[2,3],bp[2,3]->-bp[2,3]-21/2 e[2,3]-e[2] zeta[3],b[2,4]->-b[2,4]-2 e[2] e[4]+2/9 e[2,4],bp[2,4]->-bp[2,4]-20/3 e[2,4]-6 e[3] zeta[3],b[2,2,2]->-b[2,2,2]+12 e[2] e[2,2]-63/25 e[3] zeta[3],nablaB[n_,k_]:>nablaBarBBar[n,k],nablaBp[n_,k_]:>nablaBarBpBar[n,k],nablaBarBBar[n_,k_]:>nablaB[n,k],nablaBarBpBar[n_,k_]:>nablaBp[n,k]}//CSort;


cHolCR::usage="Expects a list of matrices representing an MGF and returns the holomorphic Cauchy--Riemann derivative of that MGF.";
cHolCR[mlist_]:=Block[{result},
result=Sum[Sum[mlist[[matidx,1,colidx]]c@@MapAt[(#+1)&,MapAt[(#-1)&,mlist,{matidx,2,colidx}],{matidx,1,colidx}],{colidx,1,Length[mlist[[matidx,1]]]}],{matidx,1,Length[mlist]}];
Return[result]];

cHolCR::usage="Expects a list of matrices representing an MGF and returns the antiholomorphic Cauchy--Riemann derivative of that MGF.";
cAHolCR[mlist_]:=Block[{result},
result=Sum[Sum[mlist[[matidx,2,colidx]]c@@MapAt[(#-1)&,MapAt[(#+1)&,mlist,{matidx,2,colidx}],{matidx,1,colidx}],{colidx,1,Length[mlist[[matidx,1]]]}],{matidx,1,Length[mlist]}];
Return[result]];

CHolCR::derOfDiv="Warning: You are generating the holomorphic Cauchy-Riemann derivative of the divergent expression `1`. This may be problematic.";
CHolCR::wrongDivDerArg="Wrong argument `1` for divDer: allowed are True and False";
Options[CHolCR]={divDer->True};
CHolCR[exp_,OptionsPattern[]]:=Block[{result},
If[ContainsNone[{True,False},{OptionValue[divDer]}],Message[CHolCR::wrongDivDerArg,OptionValue[divDer]];Return[exp]];
Check[Quiet[CModWeight[exp],{CModWeight::UnknownExp}],Return[Nothing]];
If[!CCheckConv[exp],Message[CHolCR::derOfDiv,exp]];
If[!OptionValue[divDer]&&!CCheckConv[exp],Return[Nothing]];
result=If[!CCheckConv[exp]&&CListHSRs[exp]!={},CSimplify[exp,useIds->False,repGHat2->False,momSimplify->False],exp];
result=CConvertFromNablaE[result];
result=result/.x_[\[Tau]]:>x/.{mgf_c:>mgf[\[Tau]],a[ab_]:>c[ab][\[Tau]]-c[Reverse[ab]][\[Tau]],g[n_]/;n>2:>c[{
 {n, 0},
 {0, 0}
}][\[Tau]],g[2]->g[2][\[Tau]],Derivative[n_][g[2]]:>Derivative[n][g[2]][\[Tau]],gHat[2]->c[{
 {2, 0},
 {0, 0}
}][\[Tau]],gBarHat[2]->gBarHat[2][\[Tau]],e[n_]:>(tau[2]/\[Pi])^n c[{
 {n, 0},
 {n, 0}
}][\[Tau]]};
result=D[result,\[Tau]];
result=result/.{D[mgf_c[\[Tau]],\[Tau]]:>cHolCR[List@@mgf],D[tau[2],\[Tau]]->0,D[gBarHat[2][\[Tau]],\[Tau]]->\[Pi]/tau[2]};
result=result/.{mgf_c[\[Tau]]:>mgf,gHat[2][\[Tau]]->gHat[2],gBarHat[2][\[Tau]]->gBarHat[2],g[2][\[Tau]]->g[2],Derivative[n_][g[2]][\[Tau]]:>Derivative[n][g[2]]};
Return[result]];

CAHolCR::derOfDiv="Warning: You are generating the antiholomorphic Cauchy-Riemann derivative of the divergent expression `1`. This may be problematic.";
CAHolCR::wrongDivDerArg="Wrong argument `1` for divDer: allowed are True and False";
Options[CAHolCR]={divDer->True};
CAHolCR[exp_,OptionsPattern[]]:=Block[{result},
If[ContainsNone[{True,False},{OptionValue[divDer]}],Message[CAHolCR::wrongDivDerArg,OptionValue[divDer]];Return[exp]];
Check[Quiet[CModWeight[exp],{CModWeight::UnknownExp}],Return[Nothing]];
If[!CCheckConv[exp],Message[CAHolCR::derOfDiv,exp]];
If[!OptionValue[divDer]&&!CCheckConv[exp],Return[Nothing]];
result=If[!CCheckConv[exp]&&CListHSRs[exp]!={},CSimplify[exp,useIds->False,repGHat2->False,momSimplify->False],exp];
result=CConvertFromNablaE[result];
result=result/.{mgf_c:>mgf[\[Tau]],a[ab_]:>c[ab][\[Tau]]-c[Reverse[ab]][\[Tau]],gBar[n_]/;n>2:>c[{
 {0, 0},
 {n, 0}
}][\[Tau]],gBar[2]->gBar[2][\[Tau]],Derivative[n_][gBar[2]]:>Derivative[n][gBar[2]][\[Tau]],gHat[2]->gHat[2][\[Tau]],gBarHat[2]->c[{
 {0, 0},
 {2, 0}
}][\[Tau]],e[n_]:>(tau[2]/\[Pi])^n c[{
 {n, 0},
 {n, 0}
}][\[Tau]]};
result=D[result,\[Tau]];
result=result/.{D[mgf_c[\[Tau]],\[Tau]]:>cAHolCR[List@@mgf],D[tau[2],\[Tau]]->0,D[gHat[2][\[Tau]],\[Tau]]->\[Pi]/tau[2]};
result=result/.{mgf_c[\[Tau]]:>mgf,gHat[2][\[Tau]]->gHat[2],gBarHat[2][\[Tau]]->gBarHat[2],gBar[2][\[Tau]]->gBar[2],Derivative[n_][gBar[2]][\[Tau]]:>Derivative[n][gBar[2]]};
Return[result]];


Options[CSimplify]=DeleteDuplicates[Join[Options[DiCSimplify],Options[TriCSimplify],Options[TetCSimplify]]];
CSimplify[exp_,opts:OptionsPattern[]]:=Block[{result},
cSimplifyWarnings={};
insideCSimplify=True;result=FixedPoint[DiCSimplify[TriCSimplify[TetCSimplify[#],FilterRules[{opts}, Options[TriCSimplify]]],FilterRules[{opts}, Options[DiCSimplify]]]&,exp];
insideCSimplify=False;
Return[result]];


CConvertToNablaE[exp_]:=Expand[CSort[exp]//.{
c[{
 {a_, 0},
 {b_, 0}
}]/;a>=b:>(\[Pi]^((a+b)/2) ((a+b)/2-1)!)/(tau[2]^a (a-1)!) nablaE[(a-b)/2,{(a+b)/2}],
c[{
 {b_, 0},
 {a_, 0}
}]/;a>=b:>(\[Pi]^((a+b)/2) ((a+b)/2-1)!)/(tau[2]^a (a-1)!) nablaBarE[(a-b)/2,{(a+b)/2}],
(*(4,4)*)
c[{
 {1, 1, 2},
 {1, 1, 2}
}]->(\[Pi]/tau[2])^4 (e[2,2]+9/10 e[4]),
(*(5,3)*)
c[{
 {1, 1, 3},
 {1, 1, 1}
}]->(2 \[Pi]^4 nablaE[1,{4}])/(5 tau[2]^5)+(\[Pi]^4 nablaE[1,{2,2}])/tau[2]^5,
c[{
 {1, 1, 1},
 {1, 1, 3}
}]->(2 \[Pi]^4 nablaBarE[1,{4}])/(5 tau[2]^5)+(\[Pi]^4 nablaBarE[1,{2,2}])/tau[2]^5,
(*(5,5)*)
c[{
 {1, 1, 3},
 {1, 1, 3}
}]->(\[Pi]/tau[2])^5 (43/35 e[5]+e[2,3]),
a[{
 {0, 1, 2, 2},
 {1, 1, 0, 3}
}]->-((\[Pi]^5 nablaBarE[1,{3}] nablaE[1,{2}])/(6 tau[2]^7))+(\[Pi]^5 nablaBarE[1,{2}] nablaE[1,{3}])/(6 tau[2]^7)+(\[Pi]^5 b[2,3])/tau[2]^5,
a[{
 {0, 2, 3},
 {3, 0, 2}
}]->-((2 \[Pi]^5 b[2,3])/tau[2]^5)+(2 \[Pi]^5 bp[2,3])/tau[2]^5+(21 \[Pi]^5 e[2,3])/(2 tau[2]^5)+(\[Pi]^5 e[2] zeta[3])/tau[2]^5,
(*(6,4)*)
c[{
 {1, 2, 3},
 {1, 0, 3}
}]->-((\[Pi]^5 nablaB[1,{2,3}])/(12 tau[2]^6))+(\[Pi]^5 nablaBp[1,{2,3}])/(12 tau[2]^6)+(\[Pi]^5 e[3] nablaE[1,{2}])/(8 tau[2]^6)-(\[Pi]^5 e[2] nablaE[1,{3}])/(8 tau[2]^6)+(7 \[Pi]^5 nablaE[1,{5}])/(40 tau[2]^6)+(7 \[Pi]^5 nablaE[1,{2,3}])/(16 tau[2]^6)+(\[Pi]^5 nablaE[1,{2}] zeta[3])/(24 tau[2]^6),
c[{
 {0, 1, 3},
 {2, 1, 3}
}]->-((\[Pi]^5 nablaBarBBar[1,{2,3}])/(12 tau[2]^6))+(\[Pi]^5 nablaBarBpBar[1,{2,3}])/(12 tau[2]^6)+(\[Pi]^5 e[3] nablaBarE[1,{2}])/(8 tau[2]^6)-(\[Pi]^5 e[2] nablaBarE[1,{3}])/(8 tau[2]^6)+(7 \[Pi]^5 nablaBarE[1,{5}])/(40 tau[2]^6)+(7 \[Pi]^5 nablaBarE[1,{2,3}])/(16 tau[2]^6)+(\[Pi]^5 nablaBarE[1,{2}] zeta[3])/(24 tau[2]^6),
c[{
 {1, 1, 4},
 {1, 1, 2}
}]->(\[Pi]^5 nablaB[1,{2,3}])/(18 tau[2]^6)-(\[Pi]^5 nablaBp[1,{2,3}])/(18 tau[2]^6)-(\[Pi]^5 e[3] nablaE[1,{2}])/(12 tau[2]^6)+(\[Pi]^5 e[2] nablaE[1,{3}])/(12 tau[2]^6)+(41 \[Pi]^5 nablaE[1,{5}])/(140 tau[2]^6)+(\[Pi]^5 nablaE[1,{2,3}])/(24 tau[2]^6)-(\[Pi]^5 nablaE[1,{2}] zeta[3])/(36 tau[2]^6),c[{
 {1, 1, 2},
 {1, 1, 4}
}]->(\[Pi]^5 nablaBarBBar[1,{2,3}])/(18 tau[2]^6)-(\[Pi]^5 nablaBarBpBar[1,{2,3}])/(18 tau[2]^6)-(\[Pi]^5 e[3] nablaBarE[1,{2}])/(12 tau[2]^6)+(\[Pi]^5 e[2] nablaBarE[1,{3}])/(12 tau[2]^6)+(41 \[Pi]^5 nablaBarE[1,{5}])/(140 tau[2]^6)+(\[Pi]^5 nablaBarE[1,{2,3}])/(24 tau[2]^6)-(\[Pi]^5 nablaBarE[1,{2}] zeta[3])/(36 tau[2]^6),c[{
 {1, 1, 1, 3},
 {0, 1, 1, 2}
}]->-((2 \[Pi]^5 nablaB[1,{2,3}])/(3 tau[2]^6))+(\[Pi]^5 nablaBp[1,{2,3}])/(6 tau[2]^6)+(\[Pi]^5 e[3] nablaE[1,{2}])/tau[2]^6-(4 \[Pi]^5 e[2] nablaE[1,{3}])/(3 tau[2]^6)-(81 \[Pi]^5 nablaE[1,{5}])/(140 tau[2]^6)-(\[Pi]^5 nablaE[1,{2,3}])/tau[2]^6+(\[Pi]^5 nablaE[1,{2}] zeta[3])/(3 tau[2]^6),c[{
 {0, 1, 1, 2},
 {1, 1, 1, 3}
}]->-((2 \[Pi]^5 nablaBarBBar[1,{2,3}])/(3 tau[2]^6))+(\[Pi]^5 nablaBarBpBar[1,{2,3}])/(6 tau[2]^6)+(\[Pi]^5 e[3] nablaBarE[1,{2}])/tau[2]^6-(4 \[Pi]^5 e[2] nablaBarE[1,{3}])/(3 tau[2]^6)-(81 \[Pi]^5 nablaBarE[1,{5}])/(140 tau[2]^6)-(\[Pi]^5 nablaBarE[1,{2,3}])/tau[2]^6+(\[Pi]^5 nablaBarE[1,{2}] zeta[3])/(3 tau[2]^6),
(*(7,3)*)
c[{
 {0, 2, 5},
 {1, 0, 2}
}]->(\[Pi]^5 nablaE[1,{2}] nablaE[1,{3}])/(6 tau[2]^7)+(31 \[Pi]^5 nablaE[2,{5}])/(420 tau[2]^7)+(\[Pi]^5 nablaE[2,{2,3}])/(4 tau[2]^7),
c[{
 {0, 1, 2},
 {2, 0, 5}
}]->(\[Pi]^5 nablaBarE[1,{2}] nablaBarE[1,{3}])/(6 tau[2]^7)+(31 \[Pi]^5 nablaBarE[2,{5}])/(420 tau[2]^7)+(\[Pi]^5 nablaBarE[2,{2,3}])/(4 tau[2]^7),c[{
 {1, 1, 5},
 {1, 1, 1}
}]->-((\[Pi]^5 nablaBp[2,{2,3}])/(126 tau[2]^7))+(\[Pi]^5 nablaE[1,{2}] nablaE[1,{3}])/(12 tau[2]^7)+(37 \[Pi]^5 nablaE[2,{5}])/(420 tau[2]^7)+(\[Pi]^5 nablaE[2,{2,3}])/(8 tau[2]^7),c[{
 {1, 1, 1},
 {1, 1, 5}
}]->-((\[Pi]^5 nablaBarBpBar[2,{2,3}])/(126 tau[2]^7))+(\[Pi]^5 nablaBarE[1,{2}] nablaBarE[1,{3}])/(12 tau[2]^7)+(37 \[Pi]^5 nablaBarE[2,{5}])/(420 tau[2]^7)+(\[Pi]^5 nablaBarE[2,{2,3}])/(8 tau[2]^7),
(*(8,2)*)
c[{
 {0, 3, 5},
 {1, 0, 1}
}]->(5 \[Pi]^5 nablaBp[3,{2,3}])/(504 tau[2]^8)-(\[Pi]^5 nablaE[1,{2}] nablaE[2,{3}])/(4 tau[2]^8)+(3 \[Pi]^5 nablaE[3,{5}])/(112 tau[2]^8),
c[{
 {0, 1, 1},
 {3, 0, 5}
}]->(5 \[Pi]^5 nablaBarBpBar[3,{2,3}])/(504 tau[2]^8)-(\[Pi]^5 nablaBarE[1,{2}] nablaBarE[2,{3}])/(4 tau[2]^8)+(3 \[Pi]^5 nablaBarE[3,{5}])/(112 tau[2]^8),
(*(6,6)*)
c[{
 {1, 2, 3},
 {1, 2, 3}
}]->(11 \[Pi]^6 e[6])/(14 tau[2]^6)-(17 \[Pi]^6 e[3,3])/(9 tau[2]^6)+(20 \[Pi]^6 ep[3,3])/(3 tau[2]^6),
c[{
 {2, 2, 2},
 {2, 2, 2}
}]->-((9 \[Pi]^6 e[6])/(7 tau[2]^6))+(20 \[Pi]^6 e[3,3])/(3 tau[2]^6)-(20 \[Pi]^6 ep[3,3])/tau[2]^6,
c[{
 {1, 1, 4},
 {1, 1, 4}
}]->(167 \[Pi]^6 e[6])/(126 tau[2]^6)+(\[Pi]^6 e[2,4])/(9 tau[2]^6)-(\[Pi]^6 e[3,3])/(9 tau[2]^6),
c[{
 {1, 1, 2, 2},
 {1, 1, 2, 2}
}]->(2 \[Pi]^6 e[3]^2)/tau[2]^6+(\[Pi]^6 e[2] e[4])/tau[2]^6-(73 \[Pi]^6 e[6])/(63 tau[2]^6)+(2 \[Pi]^6 e[2,4])/(45 tau[2]^6)-(22 \[Pi]^6 e[3,3])/(9 tau[2]^6)-(\[Pi]^6 e[2,2,2])/tau[2]^6+(80 \[Pi]^6 ep[3,3])/(3 tau[2]^6),
a[{
 {0, 2, 4},
 {5, 0, 1}
}]->-((\[Pi]^6 nablaBarE[1,{4}] nablaE[1,{2}])/(4 tau[2]^8))+(\[Pi]^6 nablaBarE[1,{2}] nablaE[1,{4}])/(4 tau[2]^8)+(\[Pi]^6 b[2,4])/tau[2]^6+(\[Pi]^6 e[2] e[4])/tau[2]^6-(\[Pi]^6 e[2,4])/(9 tau[2]^6),a[{
 {0, 1, 2, 3},
 {2, 1, 3, 0}
}]->(\[Pi]^6 nablaBarE[1,{4}] nablaE[1,{2}])/(20 tau[2]^8)-(\[Pi]^6 nablaBarE[1,{2,2}] nablaE[1,{2}])/(2 tau[2]^8)-(\[Pi]^6 nablaBarE[1,{2}] nablaE[1,{4}])/(20 tau[2]^8)+(\[Pi]^6 nablaBarE[1,{2}] nablaE[1,{2,2}])/(2 tau[2]^8)+(113 \[Pi]^6 b[2,4])/(20 tau[2]^6)+(\[Pi]^6 b[2,2,2])/(4 tau[2]^6)-(121 \[Pi]^6 bp[2,4])/(200 tau[2]^6)+(113 \[Pi]^6 e[2] e[4])/(20 tau[2]^6)-(3 \[Pi]^6 e[2] e[2,2])/(2 tau[2]^6)-(119 \[Pi]^6 e[2,4])/(45 tau[2]^6)-(3 \[Pi]^6 e[3] zeta[3])/(2 tau[2]^6),
a[{
 {0, 2, 2, 2},
 {3, 0, 1, 2}
}]->(\[Pi]^6 bp[2,4])/tau[2]^6+(10 \[Pi]^6 e[2,4])/(3 tau[2]^6)+(3 \[Pi]^6 e[3] zeta[3])/tau[2]^6,
(*(7,5)*)
c[{
 {0, 1, 6},
 {1, 4, 0}
}]->(\[Pi]^6 nablaBarE[1,{2}] nablaE[2,{4}])/(40 tau[2]^9)+(\[Pi]^6 nablaB[1,{2,4}])/(40 tau[2]^7)+(\[Pi]^6 e[2] nablaE[1,{4}])/(20 tau[2]^7)-(467 \[Pi]^6 nablaE[1,{6}])/(1260 tau[2]^7)+(\[Pi]^6 nablaE[1,{2,4}])/(90 tau[2]^7)-(\[Pi]^6 nablaE[1,{3,3}])/(18 tau[2]^7),c[{
 {0, 1, 6},
 {2, 3, 0}
}]->(\[Pi]^6 nablaBarE[1,{2}] nablaE[2,{4}])/(40 tau[2]^9)+(3 \[Pi]^6 nablaB[1,{2,4}])/(20 tau[2]^7)+(\[Pi]^6 e[2] nablaE[1,{4}])/(20 tau[2]^7)+(11 \[Pi]^6 nablaE[1,{6}])/(45 tau[2]^7)+(\[Pi]^6 nablaE[1,{2,4}])/(90 tau[2]^7)-(\[Pi]^6 nablaE[1,{3,3}])/(2 tau[2]^7)+(5 \[Pi]^6 nablaEp[1,{3,3}])/(3 tau[2]^7),c[{
 {0, 2, 5},
 {2, 3, 0}
}]->(3 \[Pi]^6 nablaB[1,{2,4}])/(8 tau[2]^7)+(125 \[Pi]^6 nablaE[1,{6}])/(84 tau[2]^7)-(5 \[Pi]^6 nablaE[1,{3,3}])/(3 tau[2]^7)+(5 \[Pi]^6 nablaEp[1,{3,3}])/tau[2]^7,c[{
 {0, 3, 4},
 {4, 0, 1}
}]->-((\[Pi]^6 nablaB[1,{2,4}])/(4 tau[2]^7))+(\[Pi]^6 e[4] nablaE[1,{2}])/tau[2]^7-(\[Pi]^6 e[2] nablaE[1,{4}])/(2 tau[2]^7)+(3 \[Pi]^6 nablaE[1,{6}])/(28 tau[2]^7)+(\[Pi]^6 nablaE[1,{2,4}])/(9 tau[2]^7)-(5 \[Pi]^6 nablaE[1,{3,3}])/(9 tau[2]^7)+(5 \[Pi]^6 nablaEp[1,{3,3}])/(3 tau[2]^7),c[{
 {1, 1, 2, 3},
 {1, 1, 2, 1}
}]->(21 \[Pi]^6 nablaB[1,{2,4}])/(40 tau[2]^7)-(\[Pi]^6 nablaB[1,{2,2,2}])/(72 tau[2]^7)+(221 \[Pi]^6 nablaBp[1,{2,4}])/(3600 tau[2]^7)+(2 \[Pi]^6 e[3] nablaE[1,{3}])/(3 tau[2]^7)+(13 \[Pi]^6 e[2] nablaE[1,{4}])/(10 tau[2]^7)+(106 \[Pi]^6 nablaE[1,{6}])/(315 tau[2]^7)+(\[Pi]^6 e[2] nablaE[1,{2,2}])/(6 tau[2]^7)+(23 \[Pi]^6 nablaE[1,{2,4}])/(90 tau[2]^7)-(19 \[Pi]^6 nablaE[1,{3,3}])/(18 tau[2]^7)-(3 \[Pi]^6 nablaE[1,{2,2,2}])/(8 tau[2]^7)+(25 \[Pi]^6 nablaEp[1,{3,3}])/(3 tau[2]^7),c[{
 {1, 2, 2, 2},
 {1, 0, 2, 2}
}]->-((21 \[Pi]^6 nablaB[1,{2,4}])/(20 tau[2]^7))+(\[Pi]^6 nablaB[1,{2,2,2}])/(36 tau[2]^7)-(221 \[Pi]^6 nablaBp[1,{2,4}])/(1800 tau[2]^7)+(\[Pi]^6 e[4] nablaE[1,{2}])/(2 tau[2]^7)+(2 \[Pi]^6 e[3] nablaE[1,{3}])/(3 tau[2]^7)-(21 \[Pi]^6 e[2] nablaE[1,{4}])/(10 tau[2]^7)-(263 \[Pi]^6 nablaE[1,{6}])/(210 tau[2]^7)-(\[Pi]^6 e[2] nablaE[1,{2,2}])/(3 tau[2]^7)-(22 \[Pi]^6 nablaE[1,{2,4}])/(45 tau[2]^7)+(8 \[Pi]^6 nablaE[1,{3,3}])/(9 tau[2]^7)+(\[Pi]^6 nablaE[1,{2,2,2}])/(4 tau[2]^7)-(10 \[Pi]^6 nablaEp[1,{3,3}])/(3 tau[2]^7),c[{
 {0, 1, 2, 4},
 {2, 1, 2, 0}
}]->(\[Pi]^6 nablaBarE[1,{3}] nablaE[2,{3}])/(36 tau[2]^9)+(\[Pi]^6 nablaBarE[1,{2}] nablaE[2,{4}])/(40 tau[2]^9)-(9 \[Pi]^6 nablaB[1,{2,4}])/(10 tau[2]^7)+(\[Pi]^6 nablaB[1,{2,2,2}])/(36 tau[2]^7)-(121 \[Pi]^6 nablaBp[1,{2,4}])/(1800 tau[2]^7)-(3 \[Pi]^6 e[2]^2 nablaE[1,{2}])/(4 tau[2]^7)+(33 \[Pi]^6 e[4] nablaE[1,{2}])/(20 tau[2]^7)+(\[Pi]^6 e[2,2] nablaE[1,{2}])/tau[2]^7+(2 \[Pi]^6 e[3] nablaE[1,{3}])/(3 tau[2]^7)+(3 \[Pi]^6 e[2] nablaE[1,{4}])/(10 tau[2]^7)-(151 \[Pi]^6 nablaE[1,{6}])/(14 tau[2]^7)+(7 \[Pi]^6 e[2] nablaE[1,{2,2}])/(6 tau[2]^7)-(9 \[Pi]^6 nablaE[1,{2,4}])/(10 tau[2]^7)+(269 \[Pi]^6 nablaE[1,{3,3}])/(18 tau[2]^7)-(\[Pi]^6 nablaE[1,{2,2,2}])/(4 tau[2]^7)-(45 \[Pi]^6 nablaEp[1,{3,3}])/tau[2]^7+(\[Pi]^6 nablaE[1,{3}] zeta[3])/(3 tau[2]^7),
(*(5,7)*)
c[{
 {0, 1, 4},
 {6, 0, 1}
}]->(\[Pi]^6 nablaBarE[2,{4}] nablaE[1,{2}])/(40 tau[2]^9)+(\[Pi]^6 nablaBarBBar[1,{2,4}])/(40 tau[2]^7)+(\[Pi]^6 e[2] nablaBarE[1,{4}])/(20 tau[2]^7)-(467 \[Pi]^6 nablaBarE[1,{6}])/(1260 tau[2]^7)+(\[Pi]^6 nablaBarE[1,{2,4}])/(90 tau[2]^7)-(\[Pi]^6 nablaBarE[1,{3,3}])/(18 tau[2]^7),c[{
 {0, 2, 3},
 {6, 0, 1}
}]->(\[Pi]^6 nablaBarE[2,{4}] nablaE[1,{2}])/(40 tau[2]^9)+(3 \[Pi]^6 nablaBarBBar[1,{2,4}])/(20 tau[2]^7)+(\[Pi]^6 e[2] nablaBarE[1,{4}])/(20 tau[2]^7)+(11 \[Pi]^6 nablaBarE[1,{6}])/(45 tau[2]^7)+(\[Pi]^6 nablaBarE[1,{2,4}])/(90 tau[2]^7)-(\[Pi]^6 nablaBarE[1,{3,3}])/(2 tau[2]^7)+(5 \[Pi]^6 nablaBarEp[1,{3,3}])/(3 tau[2]^7),c[{
 {0, 2, 3},
 {5, 0, 2}
}]->(3 \[Pi]^6 nablaBarBBar[1,{2,4}])/(8 tau[2]^7)+(125 \[Pi]^6 nablaBarE[1,{6}])/(84 tau[2]^7)-(5 \[Pi]^6 nablaBarE[1,{3,3}])/(3 tau[2]^7)+(5 \[Pi]^6 nablaBarEp[1,{3,3}])/tau[2]^7,c[{
 {0, 1, 4},
 {3, 4, 0}
}]->-((\[Pi]^6 nablaBarBBar[1,{2,4}])/(4 tau[2]^7))+(\[Pi]^6 e[4] nablaBarE[1,{2}])/tau[2]^7-(\[Pi]^6 e[2] nablaBarE[1,{4}])/(2 tau[2]^7)+(3 \[Pi]^6 nablaBarE[1,{6}])/(28 tau[2]^7)+(\[Pi]^6 nablaBarE[1,{2,4}])/(9 tau[2]^7)-(5 \[Pi]^6 nablaBarE[1,{3,3}])/(9 tau[2]^7)+(5 \[Pi]^6 nablaBarEp[1,{3,3}])/(3 tau[2]^7),c[{
 {1, 1, 1, 2},
 {1, 1, 3, 2}
}]->(21 \[Pi]^6 nablaBarBBar[1,{2,4}])/(40 tau[2]^7)-(\[Pi]^6 nablaBarBBar[1,{2,2,2}])/(72 tau[2]^7)+(221 \[Pi]^6 nablaBarBpBar[1,{2,4}])/(3600 tau[2]^7)+(2 \[Pi]^6 e[3] nablaBarE[1,{3}])/(3 tau[2]^7)+(13 \[Pi]^6 e[2] nablaBarE[1,{4}])/(10 tau[2]^7)+(106 \[Pi]^6 nablaBarE[1,{6}])/(315 tau[2]^7)+(\[Pi]^6 e[2] nablaBarE[1,{2,2}])/(6 tau[2]^7)+(23 \[Pi]^6 nablaBarE[1,{2,4}])/(90 tau[2]^7)-(19 \[Pi]^6 nablaBarE[1,{3,3}])/(18 tau[2]^7)-(3 \[Pi]^6 nablaBarE[1,{2,2,2}])/(8 tau[2]^7)+(25 \[Pi]^6 nablaBarEp[1,{3,3}])/(3 tau[2]^7),c[{
 {0, 1, 2, 2},
 {2, 1, 2, 2}
}]->-((21 \[Pi]^6 nablaBarBBar[1,{2,4}])/(20 tau[2]^7))+(\[Pi]^6 nablaBarBBar[1,{2,2,2}])/(36 tau[2]^7)-(221 \[Pi]^6 nablaBarBpBar[1,{2,4}])/(1800 tau[2]^7)+(\[Pi]^6 e[4] nablaBarE[1,{2}])/(2 tau[2]^7)+(2 \[Pi]^6 e[3] nablaBarE[1,{3}])/(3 tau[2]^7)-(21 \[Pi]^6 e[2] nablaBarE[1,{4}])/(10 tau[2]^7)-(263 \[Pi]^6 nablaBarE[1,{6}])/(210 tau[2]^7)-(\[Pi]^6 e[2] nablaBarE[1,{2,2}])/(3 tau[2]^7)-(22 \[Pi]^6 nablaBarE[1,{2,4}])/(45 tau[2]^7)+(8 \[Pi]^6 nablaBarE[1,{3,3}])/(9 tau[2]^7)+(\[Pi]^6 nablaBarE[1,{2,2,2}])/(4 tau[2]^7)-(10 \[Pi]^6 nablaBarEp[1,{3,3}])/(3 tau[2]^7),c[{
 {0, 1, 2, 2},
 {4, 1, 0, 2}
}]->(\[Pi]^6 nablaBarE[2,{4}] nablaE[1,{2}])/(40 tau[2]^9)+(\[Pi]^6 nablaBarE[2,{3}] nablaE[1,{3}])/(36 tau[2]^9)-(9 \[Pi]^6 nablaBarBBar[1,{2,4}])/(10 tau[2]^7)+(\[Pi]^6 nablaBarBBar[1,{2,2,2}])/(36 tau[2]^7)-(121 \[Pi]^6 nablaBarBpBar[1,{2,4}])/(1800 tau[2]^7)-(3 \[Pi]^6 e[2]^2 nablaBarE[1,{2}])/(4 tau[2]^7)+(33 \[Pi]^6 e[4] nablaBarE[1,{2}])/(20 tau[2]^7)+(\[Pi]^6 e[2,2] nablaBarE[1,{2}])/tau[2]^7+(2 \[Pi]^6 e[3] nablaBarE[1,{3}])/(3 tau[2]^7)+(3 \[Pi]^6 e[2] nablaBarE[1,{4}])/(10 tau[2]^7)-(151 \[Pi]^6 nablaBarE[1,{6}])/(14 tau[2]^7)+(7 \[Pi]^6 e[2] nablaBarE[1,{2,2}])/(6 tau[2]^7)-(9 \[Pi]^6 nablaBarE[1,{2,4}])/(10 tau[2]^7)+(269 \[Pi]^6 nablaBarE[1,{3,3}])/(18 tau[2]^7)-(\[Pi]^6 nablaBarE[1,{2,2,2}])/(4 tau[2]^7)-(45 \[Pi]^6 nablaBarEp[1,{3,3}])/tau[2]^7+(\[Pi]^6 nablaBarE[1,{3}] zeta[3])/(3 tau[2]^7),
(*(8,4)*)
c[{
 {0, 2, 6},
 {2, 2, 0}
}]->(\[Pi]^6 nablaE[1,{3}]^2)/(3 tau[2]^8)-(\[Pi]^6 nablaE[1,{2}] nablaE[1,{4}])/(10 tau[2]^8)+(\[Pi]^6 e[2] nablaE[2,{4}])/(10 tau[2]^8)-(11 \[Pi]^6 nablaE[2,{6}])/(36 tau[2]^8)-(\[Pi]^6 nablaE[2,{2,4}])/(45 tau[2]^8)+(5 \[Pi]^6 nablaEp[2,{3,3}])/(3 tau[2]^8),c[{
 {0, 3, 5},
 {2, 2, 0}
}]->(\[Pi]^6 nablaB[2,{2,4}])/(8 tau[2]^8)+(5 \[Pi]^6 nablaE[1,{3}]^2)/(12 tau[2]^8)-(\[Pi]^6 nablaE[1,{2}] nablaE[1,{4}])/(4 tau[2]^8)+(\[Pi]^6 e[2] nablaE[2,{4}])/(4 tau[2]^8)-(23 \[Pi]^6 nablaE[2,{6}])/(84 tau[2]^8)-(\[Pi]^6 nablaE[2,{2,4}])/(18 tau[2]^8)+(5 \[Pi]^6 nablaEp[2,{3,3}])/(2 tau[2]^8),c[{
 {0, 4, 4},
 {3, 0, 1}
}]->(\[Pi]^6 nablaB[2,{2,4}])/(12 tau[2]^8)+(5 \[Pi]^6 nablaE[1,{3}]^2)/(36 tau[2]^8)-(\[Pi]^6 nablaE[1,{2}] nablaE[1,{4}])/(6 tau[2]^8)+(\[Pi]^6 e[2] nablaE[2,{4}])/(6 tau[2]^8)-(37 \[Pi]^6 nablaE[2,{6}])/(252 tau[2]^8)-(\[Pi]^6 nablaE[2,{2,4}])/(27 tau[2]^8)+(5 \[Pi]^6 nablaEp[2,{3,3}])/(6 tau[2]^8),c[{
 {1, 2, 2, 3},
 {1, 0, 2, 1}
}]->-((251 \[Pi]^6 nablaB[2,{2,4}])/(240 tau[2]^8))+(\[Pi]^6 nablaB[2,{2,2,2}])/(144 tau[2]^8)-(69 \[Pi]^6 nablaBp[2,{2,4}])/(800 tau[2]^8)+(\[Pi]^6 e[2] nablaE[1,{2}]^2)/(24 tau[2]^8)+(19 \[Pi]^6 nablaE[1,{3}]^2)/(144 tau[2]^8)-(5 \[Pi]^6 nablaE[1,{2}] nablaE[1,{4}])/(6 tau[2]^8)-(5 \[Pi]^6 nablaE[1,{2}] nablaE[1,{2,2}])/(24 tau[2]^8)+(\[Pi]^6 e[3] nablaE[2,{3}])/(12 tau[2]^8)-(251 \[Pi]^6 e[2] nablaE[2,{4}])/(120 tau[2]^8)-(89 \[Pi]^6 nablaE[2,{6}])/(840 tau[2]^8)-(59 \[Pi]^6 nablaE[2,{2,4}])/(270 tau[2]^8)+(5 \[Pi]^6 nablaEp[2,{3,3}])/(24 tau[2]^8),c[{
 {1, 2, 2, 3},
 {1, 1, 2, 0}
}]->-((3 \[Pi]^6 nablaB[2,{2,4}])/(4 tau[2]^8))-(\[Pi]^6 nablaBp[2,{2,4}])/(18 tau[2]^8)-(\[Pi]^6 nablaE[1,{3}]^2)/(16 tau[2]^8)-(\[Pi]^6 nablaE[1,{2}] nablaE[1,{4}])/(2 tau[2]^8)-(\[Pi]^6 e[3] nablaE[2,{3}])/(12 tau[2]^8)-(3 \[Pi]^6 e[2] nablaE[2,{4}])/(2 tau[2]^8)+(8 \[Pi]^6 nablaE[2,{6}])/(63 tau[2]^8)-(\[Pi]^6 nablaE[2,{2,4}])/(9 tau[2]^8)+(5 \[Pi]^6 nablaEp[2,{3,3}])/(24 tau[2]^8),
(*(4,8)*)
c[{
 {0, 2, 2},
 {6, 0, 2}
}]->(\[Pi]^6 nablaBarE[1,{3}]^2)/(3 tau[2]^8)-(\[Pi]^6 nablaBarE[1,{2}] nablaBarE[1,{4}])/(10 tau[2]^8)+(\[Pi]^6 e[2] nablaBarE[2,{4}])/(10 tau[2]^8)-(11 \[Pi]^6 nablaBarE[2,{6}])/(36 tau[2]^8)-(\[Pi]^6 nablaBarE[2,{2,4}])/(45 tau[2]^8)+(5 \[Pi]^6 nablaBarEp[2,{3,3}])/(3 tau[2]^8),c[{
 {0, 2, 2},
 {5, 0, 3}
}]->(\[Pi]^6 nablaBarBBar[2,{2,4}])/(8 tau[2]^8)+(5 \[Pi]^6 nablaBarE[1,{3}]^2)/(12 tau[2]^8)-(\[Pi]^6 nablaBarE[1,{2}] nablaBarE[1,{4}])/(4 tau[2]^8)+(\[Pi]^6 e[2] nablaBarE[2,{4}])/(4 tau[2]^8)-(23 \[Pi]^6 nablaBarE[2,{6}])/(84 tau[2]^8)-(\[Pi]^6 nablaBarE[2,{2,4}])/(18 tau[2]^8)+(5 \[Pi]^6 nablaBarEp[2,{3,3}])/(2 tau[2]^8),c[{
 {0, 1, 3},
 {4, 4, 0}
}]->(\[Pi]^6 nablaBarBBar[2,{2,4}])/(12 tau[2]^8)+(5 \[Pi]^6 nablaBarE[1,{3}]^2)/(36 tau[2]^8)-(\[Pi]^6 nablaBarE[1,{2}] nablaBarE[1,{4}])/(6 tau[2]^8)+(\[Pi]^6 e[2] nablaBarE[2,{4}])/(6 tau[2]^8)-(37 \[Pi]^6 nablaBarE[2,{6}])/(252 tau[2]^8)-(\[Pi]^6 nablaBarE[2,{2,4}])/(27 tau[2]^8)+(5 \[Pi]^6 nablaBarEp[2,{3,3}])/(6 tau[2]^8),c[{
 {0, 1, 1, 2},
 {2, 1, 3, 2}
}]->-((251 \[Pi]^6 nablaBarBBar[2,{2,4}])/(240 tau[2]^8))+(\[Pi]^6 nablaBarBBar[2,{2,2,2}])/(144 tau[2]^8)-(69 \[Pi]^6 nablaBarBpBar[2,{2,4}])/(800 tau[2]^8)+(\[Pi]^6 e[2] nablaBarE[1,{2}]^2)/(24 tau[2]^8)+(19 \[Pi]^6 nablaBarE[1,{3}]^2)/(144 tau[2]^8)-(5 \[Pi]^6 nablaBarE[1,{2}] nablaBarE[1,{4}])/(6 tau[2]^8)-(5 \[Pi]^6 nablaBarE[1,{2}] nablaBarE[1,{2,2}])/(24 tau[2]^8)+(\[Pi]^6 e[3] nablaBarE[2,{3}])/(12 tau[2]^8)-(251 \[Pi]^6 e[2] nablaBarE[2,{4}])/(120 tau[2]^8)-(89 \[Pi]^6 nablaBarE[2,{6}])/(840 tau[2]^8)-(59 \[Pi]^6 nablaBarE[2,{2,4}])/(270 tau[2]^8)+(5 \[Pi]^6 nablaBarEp[2,{3,3}])/(24 tau[2]^8),c[{
 {0, 1, 1, 2},
 {3, 1, 2, 2}
}]->-((3 \[Pi]^6 nablaBarBBar[2,{2,4}])/(4 tau[2]^8))-(\[Pi]^6 nablaBarBpBar[2,{2,4}])/(18 tau[2]^8)-(\[Pi]^6 nablaBarE[1,{3}]^2)/(16 tau[2]^8)-(\[Pi]^6 nablaBarE[1,{2}] nablaBarE[1,{4}])/(2 tau[2]^8)-(\[Pi]^6 e[3] nablaBarE[2,{3}])/(12 tau[2]^8)-(3 \[Pi]^6 e[2] nablaBarE[2,{4}])/(2 tau[2]^8)+(8 \[Pi]^6 nablaBarE[2,{6}])/(63 tau[2]^8)-(\[Pi]^6 nablaBarE[2,{2,4}])/(9 tau[2]^8)+(5 \[Pi]^6 nablaBarEp[2,{3,3}])/(24 tau[2]^8),
(*(9,3)*)
c[{
 {0, 3, 6},
 {1, 2, 0}
}]->-((7 \[Pi]^6 nablaB[3,{2,4}])/(80 tau[2]^9))-(7 \[Pi]^6 nablaBp[3,{2,4}])/(1200 tau[2]^9)-(\[Pi]^6 nablaE[1,{3}] nablaE[2,{3}])/(12 tau[2]^9)-(7 \[Pi]^6 e[2] nablaE[3,{4}])/(40 tau[2]^9)+(79 \[Pi]^6 nablaE[3,{6}])/(5040 tau[2]^9)-(5 \[Pi]^6 nablaEp[3,{3,3}])/(12 tau[2]^9),c[{
 {0, 3, 6},
 {2, 1, 0}
}]->-((\[Pi]^6 nablaB[3,{2,4}])/(16 tau[2]^9))-(7 \[Pi]^6 nablaBp[3,{2,4}])/(2400 tau[2]^9)-(\[Pi]^6 nablaE[1,{3}] nablaE[2,{3}])/(8 tau[2]^9)-(9 \[Pi]^6 nablaE[1,{2}] nablaE[2,{4}])/(40 tau[2]^9)-(\[Pi]^6 e[2] nablaE[3,{4}])/(8 tau[2]^9)+(11 \[Pi]^6 nablaE[3,{6}])/(180 tau[2]^9)-(5 \[Pi]^6 nablaEp[3,{3,3}])/(24 tau[2]^9),c[{
 {0, 4, 5},
 {2, 1, 0}
}]->-((\[Pi]^6 nablaB[3,{2,4}])/(12 tau[2]^9))-(7 \[Pi]^6 nablaBp[3,{2,4}])/(1440 tau[2]^9)-(5 \[Pi]^6 nablaE[1,{3}] nablaE[2,{3}])/(72 tau[2]^9)-(\[Pi]^6 nablaE[1,{2}] nablaE[2,{4}])/(8 tau[2]^9)-(\[Pi]^6 e[2] nablaE[3,{4}])/(6 tau[2]^9)+(37 \[Pi]^6 nablaE[3,{6}])/(1008 tau[2]^9)-(5 \[Pi]^6 nablaEp[3,{3,3}])/(24 tau[2]^9),
(*(3,9)*)
c[{
 {0, 1, 2},
 {6, 0, 3}
}]->-((7 \[Pi]^6 nablaBarBBar[3,{2,4}])/(80 tau[2]^9))-(7 \[Pi]^6 nablaBarBpBar[3,{2,4}])/(1200 tau[2]^9)-(\[Pi]^6 nablaBarE[1,{3}] nablaBarE[2,{3}])/(12 tau[2]^9)-(7 \[Pi]^6 e[2] nablaBarE[3,{4}])/(40 tau[2]^9)+(79 \[Pi]^6 nablaBarE[3,{6}])/(5040 tau[2]^9)-(5 \[Pi]^6 nablaBarEp[3,{3,3}])/(12 tau[2]^9),c[{
 {0, 1, 2},
 {6, 3, 0}
}]->-((\[Pi]^6 nablaBarBBar[3,{2,4}])/(16 tau[2]^9))-(7 \[Pi]^6 nablaBarBpBar[3,{2,4}])/(2400 tau[2]^9)-(\[Pi]^6 nablaBarE[1,{3}] nablaBarE[2,{3}])/(8 tau[2]^9)-(9 \[Pi]^6 nablaBarE[1,{2}] nablaBarE[2,{4}])/(40 tau[2]^9)-(\[Pi]^6 e[2] nablaBarE[3,{4}])/(8 tau[2]^9)+(11 \[Pi]^6 nablaBarE[3,{6}])/(180 tau[2]^9)-(5 \[Pi]^6 nablaBarEp[3,{3,3}])/(24 tau[2]^9),c[{
 {0, 1, 2},
 {5, 4, 0}
}]->-((\[Pi]^6 nablaBarBBar[3,{2,4}])/(12 tau[2]^9))-(7 \[Pi]^6 nablaBarBpBar[3,{2,4}])/(1440 tau[2]^9)-(5 \[Pi]^6 nablaBarE[1,{3}] nablaBarE[2,{3}])/(72 tau[2]^9)-(\[Pi]^6 nablaBarE[1,{2}] nablaBarE[2,{4}])/(8 tau[2]^9)-(\[Pi]^6 e[2] nablaBarE[3,{4}])/(6 tau[2]^9)+(37 \[Pi]^6 nablaBarE[3,{6}])/(1008 tau[2]^9)-(5 \[Pi]^6 nablaBarEp[3,{3,3}])/(24 tau[2]^9),
(*(10,2)*)
c[{
 {0, 4, 6},
 {1, 1, 0}
}]->-((7 \[Pi]^6 nablaBp[4,{2,4}])/(21600 tau[2]^10))+(\[Pi]^6 nablaE[2,{3}]^2)/(72 tau[2]^10)+(7 \[Pi]^6 nablaE[1,{2}] nablaE[3,{4}])/(120 tau[2]^10)-(23 \[Pi]^6 nablaE[4,{6}])/(5040 tau[2]^10),c[{
 {0, 1, 1},
 {6, 0, 4}
}]->-((7 \[Pi]^6 nablaBarBpBar[4,{2,4}])/(21600 tau[2]^10))+(\[Pi]^6 nablaBarE[2,{3}]^2)/(72 tau[2]^10)+(7 \[Pi]^6 nablaBarE[1,{2}] nablaBarE[3,{4}])/(120 tau[2]^10)-(23 \[Pi]^6 nablaBarE[4,{6}])/(5040 tau[2]^10)
}];
CConvertFromNablaE[exp_]:=Expand[exp//.{
nablaE[k_,{n_}]:>c[{
 {n+k, 0},
 {n-k, 0}
}] (tau[2]^(n+k) (n+k-1)!)/(\[Pi]^n (n-1)!),
nablaBarE[k_,{n_}]:>c[{
 {n-k, 0},
 {n+k, 0}
}] (tau[2]^(n+k) (n+k-1)!)/(\[Pi]^n (n-1)!),
(*(4,4)*)
e[2,2]->(tau[2]/\[Pi])^4 c[{
 {1, 1, 2},
 {1, 1, 2}
}]-9/10 e[4],
(*(5,3)*)
nablaE[1,{2,2}]->tau[2]^5/\[Pi]^4 (c[{
 {1, 1, 3},
 {1, 1, 1}
}]-8/5 c[{
 {5, 0},
 {3, 0}
}]),
nablaBarE[1,{2,2}]->tau[2]^5/\[Pi]^4 (c[{
 {1, 1, 1},
 {1, 1, 3}
}]-8/5 c[{
 {3, 0},
 {5, 0}
}]),
(*(5,5)*)
e[2,3]->(tau[2]/\[Pi])^5 c[{
 {1, 1, 3},
 {1, 1, 3}
}]-43/35 e[5],
b[2,3]->(a[{
 {0, 1, 2, 2},
 {1, 1, 0, 3}
}] tau[2]^5)/\[Pi]^5+(c[{
 {2, 0},
 {4, 0}
}] c[{
 {3, 0},
 {1, 0}
}] tau[2]^5)/\[Pi]^5-(c[{
 {1, 0},
 {3, 0}
}] c[{
 {4, 0},
 {2, 0}
}] tau[2]^5)/\[Pi]^5,
bp[2,3]->(129 e[5])/20+(a[{
 {0, 2, 3},
 {3, 0, 2}
}] tau[2]^5)/(2 \[Pi]^5)+(a[{
 {0, 1, 2, 2},
 {1, 1, 0, 3}
}] tau[2]^5)/\[Pi]^5+(c[{
 {2, 0},
 {4, 0}
}] c[{
 {3, 0},
 {1, 0}
}] tau[2]^5)/\[Pi]^5-(c[{
 {1, 0},
 {3, 0}
}] c[{
 {4, 0},
 {2, 0}
}] tau[2]^5)/\[Pi]^5-(21 c[{
 {1, 1, 3},
 {1, 1, 3}
}] tau[2]^5)/(4 \[Pi]^5)-1/2 e[2] zeta[3],
(*(6,4)*)
nablaE[1,{2,3}]->-((43 c[{
 {6, 0},
 {4, 0}
}] tau[2]^6)/(7 \[Pi]^5))+(3 c[{
 {1, 1, 4},
 {1, 1, 2}
}] tau[2]^6)/\[Pi]^5+(2 c[{
 {1, 2, 3},
 {1, 0, 3}
}] tau[2]^6)/\[Pi]^5,
nablaBarE[1,{2,3}]->-((43 c[{
 {4, 0},
 {6, 0}
}] tau[2]^6)/(7 \[Pi]^5))+(2 c[{
 {0, 1, 3},
 {2, 1, 3}
}] tau[2]^6)/\[Pi]^5+(3 c[{
 {1, 1, 2},
 {1, 1, 4}
}] tau[2]^6)/\[Pi]^5,
nablaB[1,{2,3}]->(3 c[{
 {3, 0},
 {1, 0}
}] e[3] tau[2]^3)/\[Pi]^2-(13 c[{
 {4, 0},
 {2, 0}
}] e[2] tau[2]^4)/(2 \[Pi]^3)+(55 c[{
 {6, 0},
 {4, 0}
}] tau[2]^6)/(4 \[Pi]^5)-(45 c[{
 {1, 1, 4},
 {1, 1, 2}
}] tau[2]^6)/(4 \[Pi]^5)-(7 c[{
 {1, 2, 3},
 {1, 0, 3}
}] tau[2]^6)/(2 \[Pi]^5)-(2 c[{
 {1, 1, 1, 3},
 {0, 1, 1, 2}
}] tau[2]^6)/\[Pi]^5+(c[{
 {3, 0},
 {1, 0}
}] tau[2]^3 zeta[3])/\[Pi]^2,nablaBp[1,{2,3}]->-((2 c[{
 {4, 0},
 {2, 0}
}] e[2] tau[2]^4)/\[Pi]^3)+(71 c[{
 {6, 0},
 {4, 0}
}] tau[2]^6)/(2 \[Pi]^5)-(27 c[{
 {1, 1, 4},
 {1, 1, 2}
}] tau[2]^6)/\[Pi]^5-(2 c[{
 {1, 2, 3},
 {1, 0, 3}
}] tau[2]^6)/\[Pi]^5-(2 c[{
 {1, 1, 1, 3},
 {0, 1, 1, 2}
}] tau[2]^6)/\[Pi]^5,
nablaBarBBar[1,{2,3}]->(3 c[{
 {1, 0},
 {3, 0}
}] e[3] tau[2]^3)/\[Pi]^2-(13 c[{
 {2, 0},
 {4, 0}
}] e[2] tau[2]^4)/(2 \[Pi]^3)+(55 c[{
 {4, 0},
 {6, 0}
}] tau[2]^6)/(4 \[Pi]^5)-(7 c[{
 {0, 1, 3},
 {2, 1, 3}
}] tau[2]^6)/(2 \[Pi]^5)-(45 c[{
 {1, 1, 2},
 {1, 1, 4}
}] tau[2]^6)/(4 \[Pi]^5)-(2 c[{
 {0, 1, 1, 2},
 {1, 1, 1, 3}
}] tau[2]^6)/\[Pi]^5+(c[{
 {1, 0},
 {3, 0}
}] tau[2]^3 zeta[3])/\[Pi]^2,nablaBarBpBar[1,{2,3}]->-((2 c[{
 {2, 0},
 {4, 0}
}] e[2] tau[2]^4)/\[Pi]^3)+(71 c[{
 {4, 0},
 {6, 0}
}] tau[2]^6)/(2 \[Pi]^5)-(2 c[{
 {0, 1, 3},
 {2, 1, 3}
}] tau[2]^6)/\[Pi]^5-(27 c[{
 {1, 1, 2},
 {1, 1, 4}
}] tau[2]^6)/\[Pi]^5-(2 c[{
 {0, 1, 1, 2},
 {1, 1, 1, 3}
}] tau[2]^6)/\[Pi]^5,
(*(7,3)*)
nablaE[2,{2,3}]->-((4 c[{
 {3, 0},
 {1, 0}
}] c[{
 {4, 0},
 {2, 0}
}] tau[2]^7)/\[Pi]^5)-(62 c[{
 {7, 0},
 {3, 0}
}] tau[2]^7)/(7 \[Pi]^5)+(4 c[{
 {0, 2, 5},
 {1, 0, 2}
}] tau[2]^7)/\[Pi]^5,
nablaBarE[2,{2,3}]->-((4 c[{
 {1, 0},
 {3, 0}
}] c[{
 {2, 0},
 {4, 0}
}] tau[2]^7)/\[Pi]^5)-(62 c[{
 {3, 0},
 {7, 0}
}] tau[2]^7)/(7 \[Pi]^5)+(4 c[{
 {0, 1, 2},
 {2, 0, 5}
}] tau[2]^7)/\[Pi]^5,
nablaBp[2,{2,3}]->(387 c[{
 {7, 0},
 {3, 0}
}] tau[2]^7)/(2 \[Pi]^5)+(63 c[{
 {0, 2, 5},
 {1, 0, 2}
}] tau[2]^7)/\[Pi]^5-(126 c[{
 {1, 1, 5},
 {1, 1, 1}
}] tau[2]^7)/\[Pi]^5,
nablaBarBpBar[2,{2,3}]->(387 c[{
 {3, 0},
 {7, 0}
}] tau[2]^7)/(2 \[Pi]^5)+(63 c[{
 {0, 1, 2},
 {2, 0, 5}
}] tau[2]^7)/\[Pi]^5-(126 c[{
 {1, 1, 1},
 {1, 1, 5}
}] tau[2]^7)/\[Pi]^5,
(*(8,2)*)
nablaBp[3,{2,3}]->(3024 c[{
 {3, 0},
 {1, 0}
}] c[{
 {5, 0},
 {1, 0}
}] tau[2]^8)/(5 \[Pi]^5)-(567 c[{
 {8, 0},
 {2, 0}
}] tau[2]^8)/\[Pi]^5+(504 c[{
 {0, 3, 5},
 {1, 0, 1}
}] tau[2]^8)/(5 \[Pi]^5),

nablaBarBpBar[3,{2,3}]->(3024 c[{
 {1, 0},
 {3, 0}
}] c[{
 {1, 0},
 {5, 0}
}] tau[2]^8)/(5 \[Pi]^5)-(567 c[{
 {2, 0},
 {8, 0}
}] tau[2]^8)/\[Pi]^5+(504 c[{
 {0, 1, 1},
 {3, 0, 5}
}] tau[2]^8)/(5 \[Pi]^5),
(*(6,6)*)
e[3,3]->(tau[2]/\[Pi])^6 (3c[{
 {1, 2, 3},
 {1, 2, 3}
}]+c[{
 {2, 2, 2},
 {2, 2, 2}
}])-15/14 e[6],
ep[3,3]->(tau[2]/\[Pi])^6 (c[{
 {1, 2, 3},
 {1, 2, 3}
}]+17/60 c[{
 {2, 2, 2},
 {2, 2, 2}
}])-59/140 e[6],
e[2,4]->(tau[2]/\[Pi])^6 (9c[{
 {1, 1, 4},
 {1, 1, 4}
}]+3c[{
 {1, 2, 3},
 {1, 2, 3}
}]+c[{
 {2, 2, 2},
 {2, 2, 2}
}])-13e[6],
e[2,2,2]->(tau[2]/\[Pi])^6 (232/45 c[{
 {2, 2, 2},
 {2, 2, 2}
}]+292/15 c[{
 {1, 2, 3},
 {1, 2, 3}
}]+2/5 c[{
 {1, 1, 4},
 {1, 1, 4}
}]-c[{
 {1, 1, 2, 2},
 {1, 1, 2, 2}
}])+2e[3]^2+e[2]e[4]-466/45 e[6],
b[2,4]->-e[2] e[4]+1/9 e[2,4]+(nablaBarE[1,{4}] nablaE[1,{2}])/(4 tau[2]^2)-(nablaBarE[1,{2}] nablaE[1,{4}])/(4 tau[2]^2)+(a[{
 {0, 2, 4},
 {5, 0, 1}
}] tau[2]^6)/\[Pi]^6,
bp[2,4]->-(10/3) e[2,4]+(a[{
 {0, 2, 2, 2},
 {3, 0, 1, 2}
}] tau[2]^6)/\[Pi]^6-3 e[3] zeta[3],b[2,2,2]->6 e[2] e[2,2]-(117 nablaBarE[1,{4}] nablaE[1,{2}])/(20 tau[2]^2)+(2 nablaBarE[1,{2,2}] nablaE[1,{2}])/tau[2]^2+(117 nablaBarE[1,{2}] nablaE[1,{4}])/(20 tau[2]^2)-(2 nablaBarE[1,{2}] nablaE[1,{2,2}])/tau[2]^2-(113 a[{
 {0, 2, 4},
 {5, 0, 1}
}] tau[2]^6)/(5 \[Pi]^6)+(4 a[{
 {0, 1, 2, 3},
 {2, 1, 3, 0}
}] tau[2]^6)/\[Pi]^6+(121 a[{
 {0, 2, 2, 2},
 {3, 0, 1, 2}
}] tau[2]^6)/(50 \[Pi]^6)-63/50 e[3] zeta[3],
(*(7,5)*)
nablaE[1,{3,3}]->-((45 c[{
 {7, 0},
 {5, 0}
}] tau[2]^7)/(7 \[Pi]^6))-(9 c[{
 {0, 1, 6},
 {1, 4, 0}
}] tau[2]^7)/\[Pi]^6+(9 c[{
 {0, 1, 6},
 {2, 3, 0}
}] tau[2]^7)/\[Pi]^6-(3 c[{
 {0, 2, 5},
 {2, 3, 0}
}] tau[2]^7)/\[Pi]^6,nablaEp[1,{3,3}]->-((6 c[{
 {3, 0},
 {1, 0}
}] e[4] tau[2]^3)/(25 \[Pi]^2))+(12 c[{
 {5, 0},
 {3, 0}
}] e[2] tau[2]^5)/(25 \[Pi]^4)+(6 c[{
 {1, 0},
 {3, 0}
}] c[{
 {6, 0},
 {2, 0}
}] tau[2]^7)/(5 \[Pi]^6)-(2061 c[{
 {7, 0},
 {5, 0}
}] tau[2]^7)/(350 \[Pi]^6)-(18 c[{
 {0, 1, 6},
 {1, 4, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(12 c[{
 {0, 1, 6},
 {2, 3, 0}
}] tau[2]^7)/(5 \[Pi]^6)-(16 c[{
 {0, 2, 5},
 {2, 3, 0}
}] tau[2]^7)/(25 \[Pi]^6)+(3 c[{
 {0, 3, 4},
 {4, 0, 1}
}] tau[2]^7)/(25 \[Pi]^6),nablaE[1,{2,2,2}]->-((118 c[{
 {3, 0},
 {1, 0}
}] e[4] tau[2]^3)/(25 \[Pi]^2))+(12 c[{
 {4, 0},
 {2, 0}
}] e[3] tau[2]^4)/\[Pi]^3+(416 c[{
 {5, 0},
 {3, 0}
}] e[2] tau[2]^5)/(25 \[Pi]^4)+(148 c[{
 {1, 0},
 {3, 0}
}] c[{
 {6, 0},
 {2, 0}
}] tau[2]^7)/(5 \[Pi]^6)-(10756 c[{
 {7, 0},
 {5, 0}
}] tau[2]^7)/(75 \[Pi]^6)-(364 c[{
 {0, 1, 6},
 {1, 4, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(216 c[{
 {0, 1, 6},
 {2, 3, 0}
}] tau[2]^7)/(5 \[Pi]^6)-(764 c[{
 {0, 2, 5},
 {2, 3, 0}
}] tau[2]^7)/(75 \[Pi]^6)+(84 c[{
 {0, 3, 4},
 {4, 0, 1}
}] tau[2]^7)/(25 \[Pi]^6)-(4 c[{
 {1, 1, 2, 3},
 {1, 1, 2, 1}
}] tau[2]^7)/\[Pi]^6-(2 c[{
 {1, 2, 2, 2},
 {1, 0, 2, 2}
}] tau[2]^7)/\[Pi]^6,nablaE[1,{2,4}]->-((36 c[{
 {3, 0},
 {1, 0}
}] e[4] tau[2]^3)/(5 \[Pi]^2))-(18 c[{
 {5, 0},
 {3, 0}
}] e[2] tau[2]^5)/(5 \[Pi]^4)-(54 c[{
 {1, 0},
 {3, 0}
}] c[{
 {6, 0},
 {2, 0}
}] tau[2]^7)/\[Pi]^6+(546 c[{
 {7, 0},
 {5, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(27 c[{
 {0, 1, 6},
 {1, 4, 0}
}] tau[2]^7)/\[Pi]^6+(27 c[{
 {0, 1, 6},
 {2, 3, 0}
}] tau[2]^7)/\[Pi]^6-(51 c[{
 {0, 2, 5},
 {2, 3, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(18 c[{
 {0, 3, 4},
 {4, 0, 1}
}] tau[2]^7)/(5 \[Pi]^6),nablaB[1,{2,4}]->(16 c[{
 {3, 0},
 {1, 0}
}] e[4] tau[2]^3)/(5 \[Pi]^2)-(32 c[{
 {5, 0},
 {3, 0}
}] e[2] tau[2]^5)/(5 \[Pi]^4)-(16 c[{
 {1, 0},
 {3, 0}
}] c[{
 {6, 0},
 {2, 0}
}] tau[2]^7)/\[Pi]^6+(392 c[{
 {7, 0},
 {5, 0}
}] tau[2]^7)/(15 \[Pi]^6)+(8 c[{
 {0, 1, 6},
 {1, 4, 0}
}] tau[2]^7)/\[Pi]^6+(8 c[{
 {0, 1, 6},
 {2, 3, 0}
}] tau[2]^7)/\[Pi]^6-(32 c[{
 {0, 2, 5},
 {2, 3, 0}
}] tau[2]^7)/(15 \[Pi]^6)-(8 c[{
 {0, 3, 4},
 {4, 0, 1}
}] tau[2]^7)/(5 \[Pi]^6),nablaBp[1,{2,4}]->(27 c[{
 {3, 0},
 {1, 0}
}] e[2]^2 tau[2]^3)/\[Pi]^2-(1467 c[{
 {3, 0},
 {1, 0}
}] e[4] tau[2]^3)/(5 \[Pi]^2)+(108 c[{
 {4, 0},
 {2, 0}
}] e[3] tau[2]^4)/\[Pi]^3+(1854 c[{
 {5, 0},
 {3, 0}
}] e[2] tau[2]^5)/(5 \[Pi]^4)-(27 c[{
 {1, 1, 3},
 {1, 1, 1}
}] e[2] tau[2]^5)/\[Pi]^4-(18 c[{
 {2, 0},
 {4, 0}
}] c[{
 {5, 0},
 {1, 0}
}] tau[2]^7)/\[Pi]^6+(792 c[{
 {1, 0},
 {3, 0}
}] c[{
 {6, 0},
 {2, 0}
}] tau[2]^7)/\[Pi]^6-(11568 c[{
 {7, 0},
 {5, 0}
}] tau[2]^7)/(5 \[Pi]^6)-(900 c[{
 {0, 1, 6},
 {1, 4, 0}
}] tau[2]^7)/\[Pi]^6+(90 c[{
 {0, 1, 6},
 {2, 3, 0}
}] tau[2]^7)/\[Pi]^6+(588 c[{
 {0, 2, 5},
 {2, 3, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(756 c[{
 {0, 3, 4},
 {4, 0, 1}
}] tau[2]^7)/(5 \[Pi]^6)-(36 c[{
 {3, 0},
 {1, 0}
}] c[{
 {1, 1, 2},
 {1, 1, 2}
}] tau[2]^7)/\[Pi]^6+(18 c[{
 {0, 1, 2, 4},
 {2, 1, 2, 0}
}] tau[2]^7)/\[Pi]^6-(36 c[{
 {1, 1, 2, 3},
 {1, 1, 2, 1}
}] tau[2]^7)/\[Pi]^6-(36 c[{
 {1, 2, 2, 2},
 {1, 0, 2, 2}
}] tau[2]^7)/\[Pi]^6-(18 c[{
 {4, 0},
 {2, 0}
}] tau[2]^4 zeta[3])/\[Pi]^3,nablaB[1,{2,2,2}]->(5967 c[{
 {3, 0},
 {1, 0}
}] e[2]^2 tau[2]^3)/(50 \[Pi]^2)-(331227 c[{
 {3, 0},
 {1, 0}
}] e[4] tau[2]^3)/(250 \[Pi]^2)+(7434 c[{
 {4, 0},
 {2, 0}
}] e[3] tau[2]^4)/(25 \[Pi]^3)+(190587 c[{
 {5, 0},
 {3, 0}
}] e[2] tau[2]^5)/(125 \[Pi]^4)-(5367 c[{
 {1, 1, 3},
 {1, 1, 1}
}] e[2] tau[2]^5)/(50 \[Pi]^4)-(1989 c[{
 {2, 0},
 {4, 0}
}] c[{
 {5, 0},
 {1, 0}
}] tau[2]^7)/(25 \[Pi]^6)+(45576 c[{
 {1, 0},
 {3, 0}
}] c[{
 {6, 0},
 {2, 0}
}] tau[2]^7)/(25 \[Pi]^6)-(782004 c[{
 {7, 0},
 {5, 0}
}] tau[2]^7)/(125 \[Pi]^6)-(13446 c[{
 {0, 1, 6},
 {1, 4, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(3933 c[{
 {0, 1, 6},
 {2, 3, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(46314 c[{
 {0, 2, 5},
 {2, 3, 0}
}] tau[2]^7)/(125 \[Pi]^6)+(81918 c[{
 {0, 3, 4},
 {4, 0, 1}
}] tau[2]^7)/(125 \[Pi]^6)-(3978 c[{
 {3, 0},
 {1, 0}
}] c[{
 {1, 1, 2},
 {1, 1, 2}
}] tau[2]^7)/(25 \[Pi]^6)+(1989 c[{
 {0, 1, 2, 4},
 {2, 1, 2, 0}
}] tau[2]^7)/(25 \[Pi]^6)-(3078 c[{
 {1, 1, 2, 3},
 {1, 1, 2, 1}
}] tau[2]^7)/(25 \[Pi]^6)-(2628 c[{
 {1, 2, 2, 2},
 {1, 0, 2, 2}
}] tau[2]^7)/(25 \[Pi]^6)-(1989 c[{
 {4, 0},
 {2, 0}
}] tau[2]^4 zeta[3])/(25 \[Pi]^3),
(*(5,7)*)
nablaBarE[1,{3,3}]->-((45 c[{
 {5, 0},
 {7, 0}
}] tau[2]^7)/(7 \[Pi]^6))-(9 c[{
 {0, 1, 4},
 {6, 0, 1}
}] tau[2]^7)/\[Pi]^6-(3 c[{
 {0, 2, 3},
 {5, 0, 2}
}] tau[2]^7)/\[Pi]^6+(9 c[{
 {0, 2, 3},
 {6, 0, 1}
}] tau[2]^7)/\[Pi]^6,nablaBarEp[1,{3,3}]->-((6 c[{
 {1, 0},
 {3, 0}
}] e[4] tau[2]^3)/(25 \[Pi]^2))+(12 c[{
 {3, 0},
 {5, 0}
}] e[2] tau[2]^5)/(25 \[Pi]^4)+(6 c[{
 {2, 0},
 {6, 0}
}] c[{
 {3, 0},
 {1, 0}
}] tau[2]^7)/(5 \[Pi]^6)-(2061 c[{
 {5, 0},
 {7, 0}
}] tau[2]^7)/(350 \[Pi]^6)+(3 c[{
 {0, 1, 4},
 {3, 4, 0}
}] tau[2]^7)/(25 \[Pi]^6)-(18 c[{
 {0, 1, 4},
 {6, 0, 1}
}] tau[2]^7)/(5 \[Pi]^6)-(16 c[{
 {0, 2, 3},
 {5, 0, 2}
}] tau[2]^7)/(25 \[Pi]^6)+(12 c[{
 {0, 2, 3},
 {6, 0, 1}
}] tau[2]^7)/(5 \[Pi]^6),nablaBarE[1,{2,2,2}]->-((118 c[{
 {1, 0},
 {3, 0}
}] e[4] tau[2]^3)/(25 \[Pi]^2))+(12 c[{
 {2, 0},
 {4, 0}
}] e[3] tau[2]^4)/\[Pi]^3+(416 c[{
 {3, 0},
 {5, 0}
}] e[2] tau[2]^5)/(25 \[Pi]^4)+(148 c[{
 {2, 0},
 {6, 0}
}] c[{
 {3, 0},
 {1, 0}
}] tau[2]^7)/(5 \[Pi]^6)-(10756 c[{
 {5, 0},
 {7, 0}
}] tau[2]^7)/(75 \[Pi]^6)+(84 c[{
 {0, 1, 4},
 {3, 4, 0}
}] tau[2]^7)/(25 \[Pi]^6)-(364 c[{
 {0, 1, 4},
 {6, 0, 1}
}] tau[2]^7)/(5 \[Pi]^6)-(764 c[{
 {0, 2, 3},
 {5, 0, 2}
}] tau[2]^7)/(75 \[Pi]^6)+(216 c[{
 {0, 2, 3},
 {6, 0, 1}
}] tau[2]^7)/(5 \[Pi]^6)-(2 c[{
 {0, 1, 2, 2},
 {2, 1, 2, 2}
}] tau[2]^7)/\[Pi]^6-(4 c[{
 {1, 1, 1, 2},
 {1, 1, 3, 2}
}] tau[2]^7)/\[Pi]^6,nablaBarE[1,{2,4}]->-((36 c[{
 {1, 0},
 {3, 0}
}] e[4] tau[2]^3)/(5 \[Pi]^2))-(18 c[{
 {3, 0},
 {5, 0}
}] e[2] tau[2]^5)/(5 \[Pi]^4)-(54 c[{
 {2, 0},
 {6, 0}
}] c[{
 {3, 0},
 {1, 0}
}] tau[2]^7)/\[Pi]^6+(546 c[{
 {5, 0},
 {7, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(18 c[{
 {0, 1, 4},
 {3, 4, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(27 c[{
 {0, 1, 4},
 {6, 0, 1}
}] tau[2]^7)/\[Pi]^6-(51 c[{
 {0, 2, 3},
 {5, 0, 2}
}] tau[2]^7)/(5 \[Pi]^6)+(27 c[{
 {0, 2, 3},
 {6, 0, 1}
}] tau[2]^7)/\[Pi]^6,nablaBarBBar[1,{2,4}]->(16 c[{
 {1, 0},
 {3, 0}
}] e[4] tau[2]^3)/(5 \[Pi]^2)-(32 c[{
 {3, 0},
 {5, 0}
}] e[2] tau[2]^5)/(5 \[Pi]^4)-(16 c[{
 {2, 0},
 {6, 0}
}] c[{
 {3, 0},
 {1, 0}
}] tau[2]^7)/\[Pi]^6+(392 c[{
 {5, 0},
 {7, 0}
}] tau[2]^7)/(15 \[Pi]^6)-(8 c[{
 {0, 1, 4},
 {3, 4, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(8 c[{
 {0, 1, 4},
 {6, 0, 1}
}] tau[2]^7)/\[Pi]^6-(32 c[{
 {0, 2, 3},
 {5, 0, 2}
}] tau[2]^7)/(15 \[Pi]^6)+(8 c[{
 {0, 2, 3},
 {6, 0, 1}
}] tau[2]^7)/\[Pi]^6,nablaBarBpBar[1,{2,4}]->(27 c[{
 {1, 0},
 {3, 0}
}] e[2]^2 tau[2]^3)/\[Pi]^2-(1467 c[{
 {1, 0},
 {3, 0}
}] e[4] tau[2]^3)/(5 \[Pi]^2)+(108 c[{
 {2, 0},
 {4, 0}
}] e[3] tau[2]^4)/\[Pi]^3+(1854 c[{
 {3, 0},
 {5, 0}
}] e[2] tau[2]^5)/(5 \[Pi]^4)-(27 c[{
 {1, 1, 1},
 {1, 1, 3}
}] e[2] tau[2]^5)/\[Pi]^4+(792 c[{
 {2, 0},
 {6, 0}
}] c[{
 {3, 0},
 {1, 0}
}] tau[2]^7)/\[Pi]^6-(18 c[{
 {1, 0},
 {5, 0}
}] c[{
 {4, 0},
 {2, 0}
}] tau[2]^7)/\[Pi]^6-(11568 c[{
 {5, 0},
 {7, 0}
}] tau[2]^7)/(5 \[Pi]^6)+(756 c[{
 {0, 1, 4},
 {3, 4, 0}
}] tau[2]^7)/(5 \[Pi]^6)-(900 c[{
 {0, 1, 4},
 {6, 0, 1}
}] tau[2]^7)/\[Pi]^6+(588 c[{
 {0, 2, 3},
 {5, 0, 2}
}] tau[2]^7)/(5 \[Pi]^6)+(90 c[{
 {0, 2, 3},
 {6, 0, 1}
}] tau[2]^7)/\[Pi]^6-(36 c[{
 {1, 0},
 {3, 0}
}] c[{
 {1, 1, 2},
 {1, 1, 2}
}] tau[2]^7)/\[Pi]^6-(36 c[{
 {0, 1, 2, 2},
 {2, 1, 2, 2}
}] tau[2]^7)/\[Pi]^6+(18 c[{
 {0, 1, 2, 2},
 {4, 1, 0, 2}
}] tau[2]^7)/\[Pi]^6-(36 c[{
 {1, 1, 1, 2},
 {1, 1, 3, 2}
}] tau[2]^7)/\[Pi]^6-(18 c[{
 {2, 0},
 {4, 0}
}] tau[2]^4 zeta[3])/\[Pi]^3,nablaBarBBar[1,{2,2,2}]->(5967 c[{
 {1, 0},
 {3, 0}
}] e[2]^2 tau[2]^3)/(50 \[Pi]^2)-(331227 c[{
 {1, 0},
 {3, 0}
}] e[4] tau[2]^3)/(250 \[Pi]^2)+(7434 c[{
 {2, 0},
 {4, 0}
}] e[3] tau[2]^4)/(25 \[Pi]^3)+(190587 c[{
 {3, 0},
 {5, 0}
}] e[2] tau[2]^5)/(125 \[Pi]^4)-(5367 c[{
 {1, 1, 1},
 {1, 1, 3}
}] e[2] tau[2]^5)/(50 \[Pi]^4)+(45576 c[{
 {2, 0},
 {6, 0}
}] c[{
 {3, 0},
 {1, 0}
}] tau[2]^7)/(25 \[Pi]^6)-(1989 c[{
 {1, 0},
 {5, 0}
}] c[{
 {4, 0},
 {2, 0}
}] tau[2]^7)/(25 \[Pi]^6)-(782004 c[{
 {5, 0},
 {7, 0}
}] tau[2]^7)/(125 \[Pi]^6)+(81918 c[{
 {0, 1, 4},
 {3, 4, 0}
}] tau[2]^7)/(125 \[Pi]^6)-(13446 c[{
 {0, 1, 4},
 {6, 0, 1}
}] tau[2]^7)/(5 \[Pi]^6)+(46314 c[{
 {0, 2, 3},
 {5, 0, 2}
}] tau[2]^7)/(125 \[Pi]^6)+(3933 c[{
 {0, 2, 3},
 {6, 0, 1}
}] tau[2]^7)/(5 \[Pi]^6)-(3978 c[{
 {1, 0},
 {3, 0}
}] c[{
 {1, 1, 2},
 {1, 1, 2}
}] tau[2]^7)/(25 \[Pi]^6)-(2628 c[{
 {0, 1, 2, 2},
 {2, 1, 2, 2}
}] tau[2]^7)/(25 \[Pi]^6)+(1989 c[{
 {0, 1, 2, 2},
 {4, 1, 0, 2}
}] tau[2]^7)/(25 \[Pi]^6)-(3078 c[{
 {1, 1, 1, 2},
 {1, 1, 3, 2}
}] tau[2]^7)/(25 \[Pi]^6)-(1989 c[{
 {2, 0},
 {4, 0}
}] tau[2]^4 zeta[3])/(25 \[Pi]^3),
(*(8,4)*)
nablaEp[2,{3,3}]->-((3 c[{
 {4, 0},
 {2, 0}
}]^2 tau[2]^8)/(2 \[Pi]^6))+(9 c[{
 {8, 0},
 {4, 0}
}] tau[2]^8)/(5 \[Pi]^6)+(4 c[{
 {0, 3, 5},
 {2, 2, 0}
}] tau[2]^8)/(5 \[Pi]^6)-(6 c[{
 {0, 4, 4},
 {3, 0, 1}
}] tau[2]^8)/(5 \[Pi]^6),nablaE[2,{2,4}]->(90 c[{
 {6, 0},
 {2, 0}
}] e[2] tau[2]^6)/\[Pi]^4+(45 c[{
 {4, 0},
 {2, 0}
}]^2 tau[2]^8)/(2 \[Pi]^6)-(36 c[{
 {3, 0},
 {1, 0}
}] c[{
 {5, 0},
 {3, 0}
}] tau[2]^8)/\[Pi]^6-(885 c[{
 {8, 0},
 {4, 0}
}] tau[2]^8)/(2 \[Pi]^6)-(45 c[{
 {0, 2, 6},
 {2, 2, 0}
}] tau[2]^8)/\[Pi]^6+(60 c[{
 {0, 3, 5},
 {2, 2, 0}
}] tau[2]^8)/\[Pi]^6-(90 c[{
 {0, 4, 4},
 {3, 0, 1}
}] tau[2]^8)/\[Pi]^6,nablaB[2,{2,4}]->(10 c[{
 {4, 0},
 {2, 0}
}]^2 tau[2]^8)/\[Pi]^6-(422 c[{
 {8, 0},
 {4, 0}
}] tau[2]^8)/(3 \[Pi]^6)-(20 c[{
 {0, 2, 6},
 {2, 2, 0}
}] tau[2]^8)/\[Pi]^6+(56 c[{
 {0, 3, 5},
 {2, 2, 0}
}] tau[2]^8)/(3 \[Pi]^6)-(16 c[{
 {0, 4, 4},
 {3, 0, 1}
}] tau[2]^8)/\[Pi]^6,nablaBp[2,{2,4}]->-((18 c[{
 {5, 0},
 {1, 0}
}] e[3] tau[2]^5)/\[Pi]^3)-(720 c[{
 {6, 0},
 {2, 0}
}] e[2] tau[2]^6)/\[Pi]^4-(783 c[{
 {4, 0},
 {2, 0}
}]^2 tau[2]^8)/(4 \[Pi]^6)+(11547 c[{
 {8, 0},
 {4, 0}
}] tau[2]^8)/(4 \[Pi]^6)+(360 c[{
 {0, 2, 6},
 {2, 2, 0}
}] tau[2]^8)/\[Pi]^6-(369 c[{
 {0, 3, 5},
 {2, 2, 0}
}] tau[2]^8)/\[Pi]^6+(783 c[{
 {0, 4, 4},
 {3, 0, 1}
}] tau[2]^8)/(2 \[Pi]^6)-(18 c[{
 {1, 2, 2, 3},
 {1, 1, 2, 0}
}] tau[2]^8)/\[Pi]^6,nablaB[2,{2,2,2}]->-((9189 c[{
 {5, 0},
 {1, 0}
}] e[3] tau[2]^5)/(25 \[Pi]^3))-(24 c[{
 {3, 0},
 {1, 0}
}]^2 e[2] tau[2]^6)/\[Pi]^4-(432 c[{
 {6, 0},
 {2, 0}
}] e[2] tau[2]^6)/(5 \[Pi]^4)-(68643 c[{
 {4, 0},
 {2, 0}
}]^2 tau[2]^8)/(200 \[Pi]^6)-(1344 c[{
 {3, 0},
 {1, 0}
}] c[{
 {5, 0},
 {3, 0}
}] tau[2]^8)/(5 \[Pi]^6)+(266367 c[{
 {8, 0},
 {4, 0}
}] tau[2]^8)/(200 \[Pi]^6)+(216 c[{
 {0, 2, 6},
 {2, 2, 0}
}] tau[2]^8)/(5 \[Pi]^6)+(4611 c[{
 {0, 3, 5},
 {2, 2, 0}
}] tau[2]^8)/(50 \[Pi]^6)-(34317 c[{
 {0, 4, 4},
 {3, 0, 1}
}] tau[2]^8)/(100 \[Pi]^6)+(60 c[{
 {3, 0},
 {1, 0}
}] c[{
 {1, 1, 3},
 {1, 1, 1}
}] tau[2]^8)/\[Pi]^6+(144 c[{
 {1, 2, 2, 3},
 {1, 0, 2, 1}
}] tau[2]^8)/\[Pi]^6-(5589 c[{
 {1, 2, 2, 3},
 {1, 1, 2, 0}
}] tau[2]^8)/(25 \[Pi]^6),
(*(4,8)*)
nablaBarEp[2,{3,3}]->-((3 c[{
 {2, 0},
 {4, 0}
}]^2 tau[2]^8)/(2 \[Pi]^6))+(9 c[{
 {4, 0},
 {8, 0}
}] tau[2]^8)/(5 \[Pi]^6)-(6 c[{
 {0, 1, 3},
 {4, 4, 0}
}] tau[2]^8)/(5 \[Pi]^6)+(4 c[{
 {0, 2, 2},
 {5, 0, 3}
}] tau[2]^8)/(5 \[Pi]^6),nablaBarE[2,{2,4}]->(90 c[{
 {2, 0},
 {6, 0}
}] e[2] tau[2]^6)/\[Pi]^4+(45 c[{
 {2, 0},
 {4, 0}
}]^2 tau[2]^8)/(2 \[Pi]^6)-(36 c[{
 {1, 0},
 {3, 0}
}] c[{
 {3, 0},
 {5, 0}
}] tau[2]^8)/\[Pi]^6-(885 c[{
 {4, 0},
 {8, 0}
}] tau[2]^8)/(2 \[Pi]^6)-(90 c[{
 {0, 1, 3},
 {4, 4, 0}
}] tau[2]^8)/\[Pi]^6+(60 c[{
 {0, 2, 2},
 {5, 0, 3}
}] tau[2]^8)/\[Pi]^6-(45 c[{
 {0, 2, 2},
 {6, 0, 2}
}] tau[2]^8)/\[Pi]^6,nablaBarBBar[2,{2,4}]->(10 c[{
 {2, 0},
 {4, 0}
}]^2 tau[2]^8)/\[Pi]^6-(422 c[{
 {4, 0},
 {8, 0}
}] tau[2]^8)/(3 \[Pi]^6)-(16 c[{
 {0, 1, 3},
 {4, 4, 0}
}] tau[2]^8)/\[Pi]^6+(56 c[{
 {0, 2, 2},
 {5, 0, 3}
}] tau[2]^8)/(3 \[Pi]^6)-(20 c[{
 {0, 2, 2},
 {6, 0, 2}
}] tau[2]^8)/\[Pi]^6,nablaBarBpBar[2,{2,4}]->-((18 c[{
 {1, 0},
 {5, 0}
}] e[3] tau[2]^5)/\[Pi]^3)-(720 c[{
 {2, 0},
 {6, 0}
}] e[2] tau[2]^6)/\[Pi]^4-(783 c[{
 {2, 0},
 {4, 0}
}]^2 tau[2]^8)/(4 \[Pi]^6)+(11547 c[{
 {4, 0},
 {8, 0}
}] tau[2]^8)/(4 \[Pi]^6)+(783 c[{
 {0, 1, 3},
 {4, 4, 0}
}] tau[2]^8)/(2 \[Pi]^6)-(369 c[{
 {0, 2, 2},
 {5, 0, 3}
}] tau[2]^8)/\[Pi]^6+(360 c[{
 {0, 2, 2},
 {6, 0, 2}
}] tau[2]^8)/\[Pi]^6-(18 c[{
 {0, 1, 1, 2},
 {3, 1, 2, 2}
}] tau[2]^8)/\[Pi]^6,nablaBarBBar[2,{2,2,2}]->-((9189 c[{
 {1, 0},
 {5, 0}
}] e[3] tau[2]^5)/(25 \[Pi]^3))-(24 c[{
 {1, 0},
 {3, 0}
}]^2 e[2] tau[2]^6)/\[Pi]^4-(432 c[{
 {2, 0},
 {6, 0}
}] e[2] tau[2]^6)/(5 \[Pi]^4)-(68643 c[{
 {2, 0},
 {4, 0}
}]^2 tau[2]^8)/(200 \[Pi]^6)-(1344 c[{
 {1, 0},
 {3, 0}
}] c[{
 {3, 0},
 {5, 0}
}] tau[2]^8)/(5 \[Pi]^6)+(266367 c[{
 {4, 0},
 {8, 0}
}] tau[2]^8)/(200 \[Pi]^6)-(34317 c[{
 {0, 1, 3},
 {4, 4, 0}
}] tau[2]^8)/(100 \[Pi]^6)+(4611 c[{
 {0, 2, 2},
 {5, 0, 3}
}] tau[2]^8)/(50 \[Pi]^6)+(216 c[{
 {0, 2, 2},
 {6, 0, 2}
}] tau[2]^8)/(5 \[Pi]^6)+(60 c[{
 {1, 0},
 {3, 0}
}] c[{
 {1, 1, 1},
 {1, 1, 3}
}] tau[2]^8)/\[Pi]^6+(144 c[{
 {0, 1, 1, 2},
 {2, 1, 3, 2}
}] tau[2]^8)/\[Pi]^6-(5589 c[{
 {0, 1, 1, 2},
 {3, 1, 2, 2}
}] tau[2]^8)/(25 \[Pi]^6),
(*(9,3)*)
nablaEp[3,{3,3}]->-((12 c[{
 {4, 0},
 {2, 0}
}] c[{
 {5, 0},
 {1, 0}
}] tau[2]^9)/\[Pi]^6)+(72 c[{
 {9, 0},
 {3, 0}
}] tau[2]^9)/(5 \[Pi]^6)-(4 c[{
 {0, 3, 6},
 {1, 2, 0}
}] tau[2]^9)/\[Pi]^6-(4 c[{
 {0, 3, 6},
 {2, 1, 0}
}] tau[2]^9)/\[Pi]^6+(36 c[{
 {0, 4, 5},
 {2, 1, 0}
}] tau[2]^9)/(5 \[Pi]^6),nablaB[3,{2,4}]->-((240 c[{
 {7, 0},
 {1, 0}
}] e[2] tau[2]^7)/\[Pi]^4)-(160 c[{
 {4, 0},
 {2, 0}
}] c[{
 {5, 0},
 {1, 0}
}] tau[2]^9)/\[Pi]^6-(480 c[{
 {3, 0},
 {1, 0}
}] c[{
 {6, 0},
 {2, 0}
}] tau[2]^9)/\[Pi]^6+(2864 c[{
 {9, 0},
 {3, 0}
}] tau[2]^9)/(3 \[Pi]^6)+(80 c[{
 {0, 3, 6},
 {1, 2, 0}
}] tau[2]^9)/(3 \[Pi]^6)-(160 c[{
 {0, 3, 6},
 {2, 1, 0}
}] tau[2]^9)/(3 \[Pi]^6),nablaBp[3,{2,4}]->(19200 c[{
 {4, 0},
 {2, 0}
}] c[{
 {5, 0},
 {1, 0}
}] tau[2]^9)/(7 \[Pi]^6)+(7200 c[{
 {3, 0},
 {1, 0}
}] c[{
 {6, 0},
 {2, 0}
}] tau[2]^9)/\[Pi]^6-(101120 c[{
 {9, 0},
 {3, 0}
}] tau[2]^9)/(7 \[Pi]^6)-(2000 c[{
 {0, 3, 6},
 {1, 2, 0}
}] tau[2]^9)/(7 \[Pi]^6)+(7600 c[{
 {0, 3, 6},
 {2, 1, 0}
}] tau[2]^9)/(7 \[Pi]^6)-(3600 c[{
 {0, 4, 5},
 {2, 1, 0}
}] tau[2]^9)/(7 \[Pi]^6),
(*(3,9)*)
nablaBarEp[3,{3,3}]->-((12 c[{
 {1, 0},
 {5, 0}
}] c[{
 {2, 0},
 {4, 0}
}] tau[2]^9)/\[Pi]^6)+(72 c[{
 {3, 0},
 {9, 0}
}] tau[2]^9)/(5 \[Pi]^6)+(36 c[{
 {0, 1, 2},
 {5, 4, 0}
}] tau[2]^9)/(5 \[Pi]^6)-(4 c[{
 {0, 1, 2},
 {6, 0, 3}
}] tau[2]^9)/\[Pi]^6-(4 c[{
 {0, 1, 2},
 {6, 3, 0}
}] tau[2]^9)/\[Pi]^6,nablaBarBBar[3,{2,4}]->-((240 c[{
 {1, 0},
 {7, 0}
}] e[2] tau[2]^7)/\[Pi]^4)-(160 c[{
 {1, 0},
 {5, 0}
}] c[{
 {2, 0},
 {4, 0}
}] tau[2]^9)/\[Pi]^6-(480 c[{
 {1, 0},
 {3, 0}
}] c[{
 {2, 0},
 {6, 0}
}] tau[2]^9)/\[Pi]^6+(2864 c[{
 {3, 0},
 {9, 0}
}] tau[2]^9)/(3 \[Pi]^6)+(80 c[{
 {0, 1, 2},
 {6, 0, 3}
}] tau[2]^9)/(3 \[Pi]^6)-(160 c[{
 {0, 1, 2},
 {6, 3, 0}
}] tau[2]^9)/(3 \[Pi]^6),nablaBarBpBar[3,{2,4}]->(19200 c[{
 {1, 0},
 {5, 0}
}] c[{
 {2, 0},
 {4, 0}
}] tau[2]^9)/(7 \[Pi]^6)+(7200 c[{
 {1, 0},
 {3, 0}
}] c[{
 {2, 0},
 {6, 0}
}] tau[2]^9)/\[Pi]^6-(101120 c[{
 {3, 0},
 {9, 0}
}] tau[2]^9)/(7 \[Pi]^6)-(3600 c[{
 {0, 1, 2},
 {5, 4, 0}
}] tau[2]^9)/(7 \[Pi]^6)-(2000 c[{
 {0, 1, 2},
 {6, 0, 3}
}] tau[2]^9)/(7 \[Pi]^6)+(7600 c[{
 {0, 1, 2},
 {6, 3, 0}
}] tau[2]^9)/(7 \[Pi]^6),
(*(10,2)*)
nablaBp[4,{2,4}]->(43200 c[{
 {5, 0},
 {1, 0}
}]^2 tau[2]^10)/(7 \[Pi]^6)+(43200 c[{
 {3, 0},
 {1, 0}
}] c[{
 {7, 0},
 {1, 0}
}] tau[2]^10)/\[Pi]^6-(298080 c[{
 {10, 0},
 {2, 0}
}] tau[2]^10)/(7 \[Pi]^6)-(21600 c[{
 {0, 4, 6},
 {1, 1, 0}
}] tau[2]^10)/(7 \[Pi]^6),
nablaBarBpBar[4,{2,4}]->(43200 c[{
 {1, 0},
 {5, 0}
}]^2 tau[2]^10)/(7 \[Pi]^6)+(43200 c[{
 {1, 0},
 {3, 0}
}] c[{
 {1, 0},
 {7, 0}
}] tau[2]^10)/\[Pi]^6-(298080 c[{
 {2, 0},
 {10, 0}
}] tau[2]^10)/(7 \[Pi]^6)-(21600 c[{
 {0, 1, 1},
 {6, 0, 4}
}] tau[2]^10)/(7 \[Pi]^6)
}];


Options[CLaurentPoly]={usey->True};
CLaurentPoly::wrongUseYArg="Wrong argument \"`1`\" for usey: Allowed are only True and False.";
CLaurentPoly[exp_,opts:OptionsPattern[]]:=Block[{nabla,result},
If[ContainsNone[{True,False},{OptionValue[usey]}],Message[CLaurentPoly::wrongUseYArg,OptionValue[usey]];Return[exp]];
result=exp//.{
e[k_]/;k>1:>(-1)^(k-1) BernoulliB[2k]/(2k)! (4y)^k+(4(2k-3)!)/((k-2)!(k-1)!) zeta[2k-1](4y)^(1-k),
e[2,2]->-y^4/20250+y zeta[3]/45+5 zeta[5]/(12 y)-zeta[3]^2/(4 y^2),
e[2,3]->-4 y^5/297675+2y^2 zeta[3]/945-zeta[5]/180-(zeta[3]zeta[5])/(2y^3)+7 zeta[7]/(16y^2),
e[3,3]->2 y^6/6251175+y zeta[5]/210+zeta[7]/(16 y)-7/64 zeta[9]/y^3+9/64 zeta[5]^2/y^4,
ep[3,3]->-y^6/18753525+y zeta[5]/630+3 zeta[7]/(160 y)-7 zeta[9]/(480 y^3),
e[2,4]->-y^6/70875+y^3 zeta[3]/525+3 zeta[7]/(40y)+25 zeta[9]/(8 y^3)-135/32 zeta[3] zeta[7]/y^4,
e[2,2,2]->(4y^6)/9568125-2y^3 zeta[3]/10125+y zeta[5]/54+zeta[3]^2/90+661/1800 zeta[7]/y-5 zeta[3] zeta[5]/(12y^2)+zeta[3]^3/(6y^3),
b[2,3]->0,
bp[2,3]->y^5/14175-(y^2 zeta[3])/45+7 zeta[5]/240-zeta[3]^2/(2y)-147 zeta[7]/(64y^2)+21zeta[3] zeta[5]/(8y^3),
bp[2,4]->(2 y^6)/42525-4/315 y^3 zeta[3]-(9 zeta[3] zeta[5])/(4 y^2)-zeta[7]/(4 y)+(225 zeta[3] zeta[7])/(16 y^4)-(125 zeta[9])/(12 y^3),
b[2,4]->-((4 y^6)/637875)-zeta[7]/(180 y)-(35 zeta[3] zeta[7])/(32 y^4)+(25 zeta[9])/(72 y^3),
b[2,2,2]->-(y^6/151875)+zeta[3]^2/10-(3 zeta[3]^3)/(2 y^3)+1/18 y zeta[5]+(311 zeta[3] zeta[5])/(200 y^2),

nablaE[n_,k_]|nablaBarE[n_,k_]:>Nest[nabla,e@@k,n] ,(*all Laurent polynomials above are real*)
nablaEp[n_,k_]|nablaBarEp[n_,k_]:>Nest[nabla,ep@@k,n] ,(*all Laurent polynomials above are real*)
nablaB[n_,k_]|nablaBarBBar[n_,k_]:>Nest[nabla,b@@k,n] ,(*all Laurent polynomials above are real*)
nablaBp[n_,k_]|nablaBarBpBar[n_,k_]:>Nest[nabla,bp@@k,n] ,(*all Laurent polynomials above are real*)
a[__]->0,
g[k_]|gBar[k_]:>2Zeta[k],
gHat[2]|gBarHat[2]->2Zeta[2]-\[Pi]^2/y
};
nabla[poly_]:=D[poly/.y->y[\[Tau]],\[Tau]]/.{y'[\[Tau]]->y^2/\[Pi],y[\[Tau]]->y};(*this replaces nabla in result automatically*)
If[!OptionValue[usey],result=result/.y->\[Pi] tau[2],result=result/.tau[2]->y/\[Pi]];
Return[Expand[result]]];


cListWeight::usage="Expects a list of modular forms and returns the sum of their modular weights.";
cListWeight[list_]:=Block[{result=list},
result=Replace[result,{x_/;Element[x,Complexes]->{0,0}},{1}];
result=result/.a_^p_:>p a;
result=result/.{zeta[__]|intConst[__]|intConstBar[__]->{0,0},s[__]:>{0,0},bCoeff[_]->{0,0},tau[2]->{-1,-1},e[__]:>{0,0},ep[__]->{0,0},b[__]->{0,0},bp[__]->{0,0},g[k_]/;k>2:>{k,0},gBar[k_]/;k>2:>{0,k},gHat[2]->{2,0},gBarHat[2]->{0,2},nablaE[k_,_]:>{0,-2k},nablaBarE[k_,_]:>{-2k,0},nablaEp[k_,_]:>{0,-2k},nablaBarEp[k_,_]:>{-2k,0},nablaB[k_,_]:>{0,-2k},nablaBarBBar[k_,_]:>{-2k,0},nablaBp[k_,_]:>{0,-2k},nablaBarBpBar[k_,_]:>{-2k,0},x_c|x_a:>Total/@(Join@@@({(List@@x/.{}->Nothing)[[All,1]],(List@@x/.{}->Nothing)[[All,2]]}))};
If[!(And@@(MatchQ[#,{x_,y_}/;Element[x,Reals]&&Element[y,Reals]]&/@result)),Message[CModWeight::UnknownExp,DeleteCases[result,{x_Integer,y_Integer}]];
result=Replace[result,Except[{x_,y_}/;Element[x,Reals]&&Element[y,Reals]]->{0,0},1];];
Return[Plus@@result]];

CModWeight::WeightNotHom="The modular weight of the argument is not homogeneous, the weights `1` appear.";
CModWeight::UnknownExp="Expression(s) `1` found whose modular weight could not be determined. The returned weight assumes them to be modular invariant.";
CModWeight[exp_]:=Block[{result=Expand[exp]},
Switch[Head[result],
Times,
result=cListWeight[List@@result];
If[result=!=Null,Return[result],Null];,
Plus,
result=CModWeight/@(List@@result);
If[MemberQ[result,Null],Return[Null]];
If[!(Equal@@result),Message[CModWeight::WeightNotHom,StringReplace[StringTake[ToString[DeleteDuplicates[result]],{2,-2}],{"}, {"->"}, {"," "->""}]];Return[Null]];
Return[result[[1]]],
_,
result=cListWeight[{result}];
If[MemberQ[result,Null],Return[Null]];
Return[result]]
];


CListHSRs[exp_]:=Cases[exp,(c[ab_]/;(If[ab=={},False,Count[ab[[1]],0]>=2]||If[ab=={},False,Count[ab[[2]],0]>=2]))|
(c[x_,y_,z_]/;(If[x=={},False,Count[x[[2]],0]>=2]||If[y=={},False,Count[y[[2]],0]>=2]||If[z=={},False,Count[z[[2]],0]>=2]||If[x=={},False,Count[x[[1]],0]>=2]||If[y=={},False,Count[y[[1]],0]>=2]||If[z=={},False,Count[z[[1]],0]>=2]||(x!={}&&y!={}&&z!={}&&((Count[x[[2]],0]>=1&&Count[y[[2]],0]>=1&&Count[z[[2]],0]>=1)||(Count[x[[1]],0]>=1&&Count[y[[1]],0]>=1&&Count[z[[1]],0]>=1)))))
,{0,Infinity}];


Options[CBasis]={basis->"C"};


CBasis::wrongBasisOpt="Invalid basis option `1`. Allowed are only the strings \"C\" and \"nablaE\".";
CBasis::incorrModWeight="The sum `1` of the holomorphic and the antiholomorphic modular weight is odd.";
CBasis::tooLowWeight="The lowest convergent total modular weight is w+\!\(\*OverscriptBox[\(w\), \(_\)]\)=4.";
CBasis::noBasis="The basis you specified is not implemented.";
CBasis[w_,wbar_,OptionsPattern[]]:=Block[{result,basisDB},
If[!MemberQ[{"C","nablaE"},OptionValue[basis]],Message[CBasis::wrongBasisOpt,OptionValue[basis]];Return[{}]];
If[OddQ[w+wbar],Message[CBasis::incorrModWeight,w+wbar];Return[{}]];
If[w+wbar<4,Message[CBasis::tooLowWeight];Return[{}]];
If[OptionValue[basis]=="C",
(*w+Overscript[w, _]=4*)
basisDB[2,2]={(\[Pi]/tau[2])^2 e[2]};
basisDB[3,1]={c[{
 {3, 0},
 {1, 0}
}]};
basisDB[1,3]=CComplexConj[basisDB[3,1]];
(*w+Overscript[w, _]=6*)
basisDB[3,3]={(\[Pi]/tau[2])^3 e[3]};
basisDB[4,2]={c[{
 {4, 0},
 {2, 0}
}]};
basisDB[5,1]={c[{
 {5, 0},
 {1, 0}
}]};
basisDB[2,4]=CComplexConj[basisDB[4,2]];
basisDB[1,5]=CComplexConj[basisDB[5,1]];
(*w+Overscript[w, _]=8*)
basisDB[4,4]={c[{
 {1, 1, 2},
 {1, 1, 2}
}],(\[Pi]/tau[2])^4 e[4],c[{
 {1, 0},
 {3, 0}
}]c[{
 {3, 0},
 {1, 0}
}],(\[Pi]/tau[2])^4 e[2]^2};
basisDB[5,3]={c[{
 {1, 1, 3},
 {1, 1, 1}
}],c[{
 {5, 0},
 {3, 0}
}],(\[Pi]/tau[2])^2 e[2]c[{
 {3, 0},
 {1, 0}
}]};
basisDB[6,2]={c[{
 {6, 0},
 {2, 0}
}],c[{
 {3, 0},
 {1, 0}
}]^2};
basisDB[7,1]={c[{
 {7, 0},
 {1, 0}
}]};
basisDB[3,5]=CComplexConj[basisDB[5,3]];
basisDB[2,6]=CComplexConj[basisDB[6,2]];
basisDB[1,7]=CComplexConj[basisDB[7,1]];
(*w+Overscript[w, _]=10*)
basisDB[5,5]={c[{
 {1, 1, 3},
 {1, 1, 3}
}],(\[Pi]/tau[2])^5 e[5],c[{
 {1, 0},
 {3, 0}
}]c[{
 {4, 0},
 {2, 0}
}],a[{
 {0, 2, 3},
 {3, 0, 2}
}],(\[Pi]/tau[2])^5 e[2]e[3],c[{
 {2, 0},
 {4, 0}
}]c[{
 {3, 0},
 {1, 0}
}],a[{
 {0, 1, 2, 2},
 {1, 1, 0, 3}
}],(\[Pi]/tau[2])^5 e[2]zeta[3]};
basisDB[6,4]={c[{
 {1, 1, 4},
 {1, 1, 2}
}],c[{
 {6, 0},
 {4, 0}
}],c[{
 {1, 0},
 {3, 0}
}]c[{
 {5, 0},
 {1, 0}
}],(\[Pi]/tau[2])^2 e[2]c[{
 {4, 0},
 {2, 0}
}],c[{
 {3, 0},
 {1, 0}
}](\[Pi]/tau[2])^3 e[3],c[{
 {1, 2, 3},
 {1, 0, 3}
}],c[{
 {1, 1, 1, 3},
 {0, 1, 1, 2}
}],(\[Pi]/tau[2])^3 c[{
 {3, 0},
 {1, 0}
}]zeta[3]};
basisDB[7,3]={c[{
 {1, 1, 5},
 {1, 1, 1}
}],c[{
 {7, 0},
 {3, 0}
}],c[{
 {3, 0},
 {1, 0}
}]c[{
 {4, 0},
 {2, 0}
}],(\[Pi]/tau[2])^2 e[2]c[{
 {5, 0},
 {1, 0}
}],c[{
 {0, 2, 5},
 {1, 0, 2}
}]};
basisDB[8,2]={c[{
 {3, 0},
 {1, 0}
}]c[{
 {5, 0},
 {1, 0}
}],c[{
 {8, 0},
 {2, 0}
}],c[{
 {0, 3, 5},
 {1, 0, 1}
}]};
basisDB[9,1]={c[{
 {9, 0},
 {1, 0}
}]};
basisDB[4,6]=CComplexConj[basisDB[6,4]];
basisDB[3,7]=CComplexConj[basisDB[7,3]];
basisDB[2,8]=CComplexConj[basisDB[8,2]];
basisDB[1,9]=CComplexConj[basisDB[9,1]];
(*w+Overscript[w, _]=12*)
basisDB[6,6]={c[{
 {1, 0},
 {3, 0}
}] c[{
 {1, 1, 3},
 {1, 1, 1}
}],c[{
 {1, 0},
 {3, 0}
}] c[{
 {5, 0},
 {3, 0}
}],(\[Pi]^2 c[{
 {1, 0},
 {3, 0}
}] c[{
 {3, 0},
 {1, 0}
}] e[2])/tau[2]^2,c[{
 {1, 0},
 {5, 0}
}] c[{
 {5, 0},
 {1, 0}
}],(\[Pi]^2 c[{
 {1, 1, 2},
 {1, 1, 2}
}] e[2])/tau[2]^2,(\[Pi]^6 e[2] e[4])/tau[2]^6,(\[Pi]^6 e[2]^3)/tau[2]^6,c[{
 {2, 0},
 {4, 0}
}] c[{
 {4, 0},
 {2, 0}
}],c[{
 {3, 0},
 {1, 0}
}] c[{
 {1, 1, 1},
 {1, 1, 3}
}],c[{
 {3, 0},
 {1, 0}
}] c[{
 {3, 0},
 {5, 0}
}],(\[Pi]^6 e[3]^2)/tau[2]^6,(\[Pi]^6 e[3] zeta[3])/tau[2]^6,(\[Pi]^6 e[6])/tau[2]^6,c[{
 {1, 2, 3},
 {1, 2, 3}
}],c[{
 {2, 2, 2},
 {2, 2, 2}
}],c[{
 {1, 1, 2, 2},
 {1, 1, 2, 2}
}],c[{
 {1, 1, 4},
 {1, 1, 4}
}],a[{
 {0, 2, 4},
 {5, 0, 1}
}],a[{
 {0, 1, 2, 3},
 {2, 1, 3, 0}
}],a[{
 {0, 2, 2, 2},
 {3, 0, 1, 2}
}]};
basisDB[7,5]={c[{
 {1, 0},
 {3, 0}
}] c[{
 {3, 0},
 {1, 0}
}]^2,c[{
 {1, 0},
 {3, 0}
}] c[{
 {6, 0},
 {2, 0}
}],(\[Pi]^2 c[{
 {1, 1, 3},
 {1, 1, 1}
}] e[2])/tau[2]^2,(\[Pi]^2 c[{
 {5, 0},
 {3, 0}
}] e[2])/tau[2]^2,(\[Pi]^4 c[{
 {3, 0},
 {1, 0}
}] e[2]^2)/tau[2]^4,c[{
 {2, 0},
 {4, 0}
}] c[{
 {5, 0},
 {1, 0}
}],c[{
 {3, 0},
 {1, 0}
}] c[{
 {1, 1, 2},
 {1, 1, 2}
}],(\[Pi]^4 c[{
 {3, 0},
 {1, 0}
}] e[4])/tau[2]^4,(\[Pi]^3 c[{
 {4, 0},
 {2, 0}
}] e[3])/tau[2]^3,(\[Pi]^3 c[{
 {4, 0},
 {2, 0}
}] zeta[3])/tau[2]^3,c[{
 {7, 0},
 {5, 0}
}],c[{
 {0, 1, 6},
 {1, 4, 0}
}],c[{
 {0, 1, 6},
 {2, 3, 0}
}],c[{
 {0, 2, 5},
 {2, 3, 0}
}],c[{
 {0, 3, 4},
 {4, 0, 1}
}],c[{
 {1, 1, 2, 3},
 {1, 1, 2, 1}
}],c[{
 {1, 2, 2, 2},
 {1, 0, 2, 2}
}],c[{
 {0, 1, 2, 4},
 {2, 1, 2, 0}
}]};
basisDB[8,4]={(\[Pi]^2 c[{
 {3, 0},
 {1, 0}
}]^2 e[2])/tau[2]^2,c[{
 {1, 0},
 {3, 0}
}] c[{
 {7, 0},
 {1, 0}
}],(\[Pi]^2 c[{
 {6, 0},
 {2, 0}
}] e[2])/tau[2]^2,c[{
 {3, 0},
 {1, 0}
}] c[{
 {1, 1, 3},
 {1, 1, 1}
}],c[{
 {3, 0},
 {1, 0}
}] c[{
 {5, 0},
 {3, 0}
}],(\[Pi]^3 c[{
 {5, 0},
 {1, 0}
}] e[3])/tau[2]^3,c[{
 {4, 0},
 {2, 0}
}]^2,(\[Pi]^3 c[{
 {5, 0},
 {1, 0}
}] zeta[3])/tau[2]^3,c[{
 {8, 0},
 {4, 0}
}],c[{
 {0, 2, 6},
 {2, 2, 0}
}],c[{
 {0, 3, 5},
 {2, 2, 0}
}],c[{
 {0, 4, 4},
 {3, 0, 1}
}],c[{
 {1, 2, 2, 3},
 {1, 0, 2, 1}
}],c[{
 {1, 2, 2, 3},
 {1, 1, 2, 0}
}]};
basisDB[9,3]={c[{
 {3, 0},
 {1, 0}
}]^3,(\[Pi]^2 c[{
 {7, 0},
 {1, 0}
}] e[2])/tau[2]^2,c[{
 {3, 0},
 {1, 0}
}] c[{
 {6, 0},
 {2, 0}
}],c[{
 {4, 0},
 {2, 0}
}] c[{
 {5, 0},
 {1, 0}
}],c[{
 {9, 0},
 {3, 0}
}],c[{
 {0, 3, 6},
 {1, 2, 0}
}],c[{
 {0, 3, 6},
 {2, 1, 0}
}],c[{
 {0, 4, 5},
 {2, 1, 0}
}]};
basisDB[10,2]={c[{
 {3, 0},
 {1, 0}
}] c[{
 {7, 0},
 {1, 0}
}],c[{
 {5, 0},
 {1, 0}
}]^2,c[{
 {10, 0},
 {2, 0}
}],c[{
 {0, 4, 6},
 {1, 1, 0}
}]};
basisDB[11,1]={c[{
 {11, 0},
 {1, 0}
}]};
basisDB[5,7]=CComplexConj[basisDB[7,5]];
basisDB[4,8]=CComplexConj[basisDB[8,4]];
basisDB[3,9]=CComplexConj[basisDB[9,3]];
basisDB[2,10]=CComplexConj[basisDB[10,2]];
basisDB[1,11]=CComplexConj[basisDB[11,1]];
];
If[OptionValue[basis]=="nablaE",
(*w+Overscript[w, _]=4*)
basisDB[2,2]={e[2]};
basisDB[3,1]={nablaE[1,{2}]};
basisDB[1,3]=CComplexConj[basisDB[3,1]];
(*w+Overscript[w, _]=6*)
basisDB[3,3]={e[3]};
basisDB[4,2]={nablaE[1,{3}]};
basisDB[5,1]={nablaE[2,{3}]};
basisDB[2,4]=CComplexConj[basisDB[4,2]];
basisDB[1,5]=CComplexConj[basisDB[5,1]];
(*w+Overscript[w, _]=8*)
basisDB[4,4]={e[2,2],e[4],1/tau[2]^2 nablaE[1,{2}]nablaBarE[1,{2}],e[2]^2};
basisDB[5,3]={nablaE[1,{2,2}],nablaE[1,{4}],e[2]nablaE[1,{2}]};
basisDB[6,2]={nablaE[2,{4}],nablaE[1,{2}]^2};
basisDB[7,1]={nablaE[3,{4}]};
basisDB[3,5]=CComplexConj[basisDB[5,3]];
basisDB[2,6]=CComplexConj[basisDB[6,2]];
basisDB[1,7]=CComplexConj[basisDB[7,1]];
(*w+Overscript[w, _]=10*)
basisDB[5,5]={e[2,3],e[5],1/tau[2]^2 nablaE[1,{3}]nablaBarE[1,{2}],e[2]e[3],1/tau[2]^2 nablaBarE[1,{3}]nablaE[1,{2}],b[2,3],bp[2,3],e[2]zeta[3]};
basisDB[6,4]={nablaE[1,{2,3}],nablaE[1,{5}],1/tau[2]^2 nablaBarE[1,{2}]nablaE[2,{3}],e[2]nablaE[1,{3}],nablaE[1,{2}]e[3],nablaB[1,{2,3}],nablaBp[1,{2,3}],nablaE[1,{2}]zeta[3]};
basisDB[7,3]={nablaE[2,{2,3}],nablaE[2,{5}],nablaE[1,{2}]nablaE[1,{3}],e[2]nablaE[2,{3}],nablaBp[2,{2,3}]};
basisDB[8,2]={nablaE[1,{2}]nablaE[2,{3}],nablaE[3,{5}],nablaBp[3,{2,3}]};
basisDB[9,1]={nablaE[4,{5}]};
basisDB[4,6]=CComplexConj[basisDB[6,4]];
basisDB[3,7]=CComplexConj[basisDB[7,3]];
basisDB[2,8]=CComplexConj[basisDB[8,2]];
basisDB[1,9]=CComplexConj[basisDB[9,1]];
(*w+Overscript[w, _]=12*)
basisDB[6,6]={(nablaBarE[1,{2}] nablaE[1,{4}])/tau[2]^2,(nablaBarE[1,{2}] nablaE[1,{2,2}])/tau[2]^2,(e[2] nablaBarE[1,{2}] nablaE[1,{2}])/tau[2]^2,(nablaBarE[2,{3}] nablaE[2,{3}])/tau[2]^4,e[2] e[4],e[2] e[2,2],e[2]^3,(nablaBarE[1,{3}] nablaE[1,{3}])/tau[2]^2,(nablaBarE[1,{4}] nablaE[1,{2}])/tau[2]^2,(nablaBarE[1,{2,2}] nablaE[1,{2}])/tau[2]^2,e[3]^2,e[3] zeta[3],e[6],e[3,3],ep[3,3],e[2,4],e[2,2,2],b[2,4],b[2,2,2],bp[2,4]};
basisDB[7,5]={(nablaBarE[1,{2}] nablaE[1,{2}]^2)/tau[2]^2,(nablaBarE[1,{2}] nablaE[2,{4}])/tau[2]^2,e[2] nablaE[1,{4}],e[2] nablaE[1,{2,2}],e[2]^2 nablaE[1,{2}],(nablaBarE[1,{3}] nablaE[2,{3}])/tau[2]^2,e[4] nablaE[1,{2}],e[2,2] nablaE[1,{2}],e[3] nablaE[1,{3}],nablaE[1,{3}] zeta[3],nablaE[1,{6}],nablaB[1,{2,4}],nablaE[1,{2,4}],nablaE[1,{3,3}],nablaEp[1,{3,3}],nablaB[1,{2,2,2}],nablaBp[1,{2,4}],nablaE[1,{2,2,2}]};
basisDB[8,4]={e[2] nablaE[1,{2}]^2,(nablaBarE[1,{2}] nablaE[3,{4}])/tau[2]^2,e[2] nablaE[2,{4}],nablaE[1,{2}] nablaE[1,{4}],nablaE[1,{2}] nablaE[1,{2,2}],e[3] nablaE[2,{3}],nablaE[1,{3}]^2,nablaE[2,{3}] zeta[3],nablaE[2,{6}],nablaE[2,{2,4}],nablaEp[2,{3,3}],nablaB[2,{2,4}],nablaB[2,{2,2,2}],nablaBp[2,{2,4}]};
basisDB[9,3]={nablaE[1,{2}]^3,e[2] nablaE[3,{4}],nablaE[1,{2}] nablaE[2,{4}],nablaE[1,{3}] nablaE[2,{3}],nablaE[3,{6}],nablaB[3,{2,4}],nablaBp[3,{2,4}],nablaEp[3,{3,3}]};
basisDB[10,2]={nablaE[1,{2}] nablaE[3,{4}],nablaE[2,{3}]^2,nablaE[4,{6}],nablaBp[4,{2,4}]};
basisDB[11,1]={nablaE[5,{6}]};
basisDB[5,7]=CComplexConj[basisDB[7,5]];
basisDB[4,8]=CComplexConj[basisDB[8,4]];
basisDB[3,9]=CComplexConj[basisDB[9,3]];
basisDB[2,10]=CComplexConj[basisDB[10,2]];
basisDB[1,11]=CComplexConj[basisDB[11,1]];
];
If[Head[basisDB[w,wbar]]===basisDB,Message[CBasis::noBasis];Return[{}]];
result=basisDB[w,wbar];
Return[result]];


Options[CSieveDecomp]={CSimplifyOpts->{basisExpandG->True},verbose->False,divDer->False,basis->{},addIds->{}};


toStringOrdinal::usage="Converts integers into strings with proper English ordinals, by popular request ;)";
toStringOrdinal[i_Integer]:=ToString[i]<>(IntegerDigits[i][[-1]]/.{1/;i!=11->"st",2/;i!=12->"nd",3/;i!=13->"rd",_->"th"});


CSieveDecomp::wrongArgAddIds="The value `1` for the option addIds is invalid: addIds should be a list of replacement rules.";
CSieveDecomp::divArg="The graph `1` is divergent. Taking derivatives of divergenet graphs is experimental, proceed with care.";
CSieveDecomp::argNotDiTri="The argument `1` is not a dihedral or trihedral graph.";
CSieveDecomp::badBasis="The basis `1` is invalid. The basis should be a list of MGFs with the same modular weight as the MGF to be decomposed. Use an empty list to get the basis from CBasis automatically.";
CSieveDecomp::divBasis="The basis element `1` is divergent. Taking derivatives of divergenet graphs is experimental, proceed with care.";
CSieveDecomp::MGFHSR="The graph `1` still allows for HSR. The sieve algorithm cannot be applied to graphs with holomorphic subgraphs.";
CSieveDecomp::basisHSR="The basis element `1` still allows for HSR. The sieve algorithm cannot be applied to graphs with holomorphic subgraphs.";
CSieveDecomp::noSol="No solution was found for the `1` derivative. You can investigate this further by setting the option verbose to True.";
CSieveDecomp::holEisenCoeffNoBasis="The `1` derivative contains the undecomposed graph(s) `2` as a coefficient of a holomorphic Eisenstein series.";
CSieveDecomp::noBasis="No basis was provided and the basis could not be found via CBasis.";
CSieveDecomp::tooManySols="More than one solution found in the `1` derivative. You can investigate this further by setting the option verbose to True.";

CSieveDecomp[mgf_,OptionsPattern[]]:=Block[{result,finalbasis,bComb,buffer,n,totalDer,holEisen,holEisenCoeff,coeffBasisElems,coeffSol,nonSimpMGF,weight,derFct},
If[Head[OptionValue[addIds]]=!=List||(OptionValue[addIds]!={}&&DeleteDuplicates[Head/@OptionValue[addIds]]=!={Rule}),Message[CSieveDecomp::wrongArgAddIds,OptionValue[addIds]];Return[mgf]];
If[OddQ[Total[CModWeight[mgf]]],Return[0]];
If[!MatchQ[mgf,c[_,_,_]|c[_]],Message[CSieveDecomp::argNotDiTri,mgf];Return[mgf]];
If[!CCheckConv[mgf],Message[CSieveDecomp::divArg,mgf];If[!OptionValue[divDer],Return[mgf]];];
If[Length[CListHSRs[mgf]]>0,Message[CSieveDecomp::MGFHSR,mgf];Return[mgf]];

If[OptionValue[basis]==={},
finalbasis=Check[CBasis@@CModWeight[mgf],Message[CSieveDecomp::noBasis];Return[mgf],{CBasis::tooLowWeight,CBasis::noBasis}];,
If[Head[OptionValue[basis]]=!=List||!Equal@@(CModWeight/@Join[{mgf},OptionValue[basis]]),
Message[CSieveDecomp::badBasis,OptionValue[basis]];Return[mgf];];
finalbasis=OptionValue[basis];
];
If[!OptionValue[divDer],
Do[If[!CCheckConv[bElem],Message[CSieveDecomp::divBasis,bElem]],{bElem,finalbasis}];
If[!And@@(CCheckConv/@finalbasis),Return[mgf]];
];
Do[If[Length[CListHSRs[{bElem}]]>0,Message[CSieveDecomp::basisHSR,bElem]],{bElem,finalbasis}];
If[Length[CListHSRs[finalbasis]]>0,Return[mgf]];

weight=CModWeight[mgf];
derFct=If[weight[[1]]>=weight[[2]],CHolCR,CAHolCR];

bComb=Inner[Times,Array[bCoeff,Length[finalbasis]],finalbasis,Plus];
totalDer=mgf-bComb;
If[Catch[
Do[
If[OptionValue[verbose],Print[toStringOrdinal[n]<>" derivative:"]];
totalDer=Expand[CSimplify[Quiet[derFct[totalDer]],Sequence@@OptionValue[CSimplifyOpts]]/.OptionValue[addIds]];
If[OptionValue[verbose],Print[Expand[Simplify[totalDer]]]];

holEisen=Cases[Variables[totalDer],g[_]|gBar[_]|gHat[2]|gBarHat[2]];
If[OptionValue[verbose],Print["(Anti-)holomorphic Eisenstein series:"];Print[holEisen];];
If[Length[holEisen]==0,If[OptionValue[verbose],Print["\n"];];Continue[];];
holEisenCoeff=DeleteCases[Delete[Flatten[CoefficientList[totalDer//CSimplify,holEisen]],1],0];
If[OptionValue[verbose],Print["Coefficients that should be zero:"];Print[holEisenCoeff]];
coeffBasisElems=DeleteDuplicates[Join[Flatten[Variables/@Join[Quiet[CBasis@@@(CModWeight/@holEisenCoeff)]]],Cases[holEisenCoeff,zeta[__]|(c[ab_]/;Dimensions[ab]=={2,2})|e[_],Infinity]]];
If[OptionValue[verbose],Print["Find solution for all"];Print[coeffBasisElems]];
nonSimpMGF=Cases[holEisenCoeff/.Join[#->1&/@coeffBasisElems,{bCoeff[_]->1,zeta[__]->1,\[Pi]->1,Rational[_,_]->1}],c[__],Infinity];

If[nonSimpMGF=={},
coeffSol=Quiet[SolveAlways[And@@(#==0&/@holEisenCoeff),coeffBasisElems]];,
Message[CSieveDecomp::holEisenCoeffNoBasis,toStringOrdinal[n],nonSimpMGF];Throw["abort"];Break[]
];
If[Length[coeffSol]>1,Message[CSieveDecomp::tooManySols,toStringOrdinal[n]];Throw["abort"];Break[]];
If[coeffSol=={},Message[CSieveDecomp::noSol,toStringOrdinal[n]];Throw["abort"];Break[]];
If[OptionValue[verbose],Print["Solutions:"];Print[coeffSol]];
totalDer=Expand[totalDer/.coeffSol[[1]]];
bComb=Expand[bComb/.coeffSol[[1]]];

If[OptionValue[verbose],Print["\n"];];
,{n,Min[weight]}];
]=="abort",Return[mgf]];

result=Expand[Simplify[bComb]];
result+=If[Equal@@weight,(\[Pi]/tau[2])^weight[[1]] intConst@@mgf,0];
Return[result]];


(*vz just generates the appropriate polynomial in fz[a,i,j]*)
vz[a_,nlist_]:=Block[{as,ijs,result},
as=Flatten[Permutations/@IntegerPartitions[a,{Length[nlist]},Range[0,a]],1];
ijs=Subsequences[Append[nlist,nlist[[1]]],{2}];
result=MapThread[fz[#1,Sequence@@#2]&,{#,ijs}]&/@as;
result=(Plus@@(Times@@@result))/.fz[0,__]->1;
Return[result]];

vBarz[a_,nlist_]:=Block[{as,ijs,result},
as=Flatten[Permutations/@IntegerPartitions[a,{Length[nlist]},Range[0,a]],1];
ijs=Subsequences[Append[nlist,nlist[[1]]],{2}];
result=MapThread[fBarz[#1,Sequence@@#2]&,{#,ijs}]&/@as;
result=(Plus@@(Times@@@result))/.fBarz[0,__]->1;
Return[result]];


frule={fz[k_,i_,j_]:>{i->j,"("<>ToString[k]<>",0)"},fBarz[k_,i_,j_]:>{i->j,"(0,"<>ToString[k]<>")"},gz[i_,j_]:>{i->j,"(1,1)"},cz[a_,b_,i_,j_]:>{i->j,"("<>ToString[a]<>","<>ToString[b]<>")"}};

gdFromfn::usage="Expects an argument given as a graph-data list. This is a list of signs for the graphs, together with the graphs given as rules for the edges and edge labels as strings.";
gdFromfn[exp_]:=If[exp===0,{},Transpose[MapThread[If[#1=!=(#1/.\[Delta][_,_]->1),{#1/.\[Delta][_,_]->1,Function[edges,{edges[[1]]//.(DeleteCases[Flatten[{#1}/.Times->List],Except[\[Delta][_,_]]]/.\[Delta]->Rule),edges[[2]]}]/@#2},{#1,#2}]&,{Flatten[{Expand[exp]/.{fz[0,_,_]->1,fBarz[0,_,_]->1}}/.Plus->List]/.{fz[w_,_,_]:>(-1)^(w-1),fBarz[w_,_,_]:>-1,gz[_,_]->tau[2]/\[Pi],cz[_,_,_,_]->1},(Flatten[#,1]&/@((List/@(Flatten[{Expand[exp]/.{fz[0,_,_]->1,fBarz[0,_,_]->1}}/.Plus->List]/(Flatten[{Expand[exp]/.{fz[0,_,_]->1,fBarz[0,_,_]->1}}/.Plus->List]/.{fz[_,_,_]->1,fBarz[_,_,_]->1,gz[_,_]->1,cz[_,_,_,_]->1})))/.Times->List/.x_^k_:>Sequence@@ConstantArray[x,k]))/.{1}->{}}/.frule]]]


displayGD::usage="Expects a graph-data list and displays the resulting term with graphs.";
displayGD[graphData_,vertexLabeling_:False]:=graphData[[1]].(If[#=={},1,GraphPlot[#,Method->"HighDimensionalEmbedding",VertexLabeling->vertexLabeling,ImageSize->Medium,DirectedEdges->True,MultiedgeStyle->0.2,EdgeRenderingFunction->({Black,Arrow[#1,If[vertexLabeling==True,0.04,0.02]],Inset[Text[Style[#3,15]],(#[[Floor[Length[#]/2]]]+#[[Ceiling[(Length[#]+1)/2]]])/2&[#1],Background->White]}&),VertexRenderingFunction->(If[vertexLabeling==True,{Black,Text[Style[#2,15],#1],Background->White},Disk[#1,0.01]]&),PlotRangePadding->0.1,Frame->True]]&/@graphData[[2]]);


cmbGD::usage="Expects two graph-data lists and combines them into one, i.e. the prefactors get multiplied and the graphs integrated into each other.";
cmbGD[graphData1_,graphData2_]:={Flatten[Table[i j,{i,graphData1[[1]]},{j,graphData2[[1]]}]],Flatten[Table[Join[i,j],{i,graphData1[[2]]},{j,graphData2[[2]]}],1]};


irredGD::usage="Expects a graph-data list and sets the prefactor of one-particle reducible graphs and of graphs with one-valent vertices to zero.";
irredGD[graphData_]:={graphData[[1]]*(If[Count[(EdgeConnectivity/@ConnectedGraphComponents[#[[All,1]]/.(i_->j_):>i<->j]),1]== 0,1,0]&/@graphData[[2]]),graphData[[2]]};


simplifyGD::usage="Expects a graph-data list and simplifies it, rewriting it into an MGF if possible.";
simplifyGD[gd_]:=Block[{irred,GDgraphs,prefs,gdToWeights,weightToNo,noToWeight,gdToGraphs,del2valGDvert,discGD},
weightToNo[s_]:=If[s==={},{{}},ToExpression[StringReplace[s,{"("->"{",")"->"}"}]]];noToWeight[list_]:=StringReplace[ToString[list],{"{"->"(","}"->")"}];gdToGraphs[list_]:=Flatten[Drop[#,-1]&/@list];gdToWeights[list_]:=Flatten[Drop[#,1]&/@list];del2valGDvert[GDgraph_,vert_]:=Delete[GDgraph,Drop[#,-1]&/@Position[gdToGraphs[GDgraph],vert]];

irred=irredGD[gd];
(*remove graphs with odd total modular weight*)
irred[[1]]=MapIndexed[If[OddQ[Total[weightToNo/@gdToWeights[#1],2]],0,1]irred[[1,#2[[1]]]]&,irred[[2]]];
prefs=DeleteCases[irred[[1]],0];
GDgraphs=Delete[irred[[2]],MapIndexed[If[#1===0,#2,Nothing]&,irred[[1]]]];

Table[(*Find all 2-valent vertices and replace them*)
GDgraphs[[i]]=FixedPoint[
Block[{graph=gdToGraphs[#],vertToNo,twovalent,al,am,newedge,weights},
vertToNo[vert_]:=Position[VertexList[graph],vert]/.List->Identity;
If[graph=={},{},
twovalent=Position[VertexDegree[graph],2];
If[twovalent=={},#,
twovalent=VertexList[graph][[Flatten[twovalent][[1]]]];
al=AdjacencyList[graph,twovalent];
am=Normal[AdjacencyMatrix[graph]];
If[al==If[$VersionNumber<11,{},If[$VersionNumber==11&&$ReleaseNumber==0,{},{twovalent}]],(*check if the 2-valent vertex is disconnected*)
(*in Version 11.0, a vertex only connected to itself is adjacent to no vertices, in version 11.3, and onwards, a vertex only connected to itself is adjacent to itself*)
weights=weightToNo[gdToWeights[#][[Position[graph,twovalent][[1,1]]]]];
prefs[[i]]*=c[Transpose[{weights,{0,0}}]];
del2valGDvert[#,twovalent],
If[Length[al]==1,(*check if both edges come from the same vertex*)
weights=weightToNo[gdToWeights[#][[Flatten[Position[graph,(twovalent->Identity@@al)|(Identity@@al->twovalent)]]]]];
newedge=Identity@@al->Identity@@al;,
weights=weightToNo[gdToWeights[#][[Flatten[(Position[graph,(twovalent->al[[#]])|(al[[#]]->twovalent)])&/@{1,2}]]]];
newedge=Rule@@al;
];
If[am[[vertToNo[twovalent],vertToNo[al[[1]]]]]!=0,prefs[[i]]*=(-1)^Total[weights[[1]]];];
If[am[[vertToNo[al[[-1]]],vertToNo[twovalent]]]!=0,prefs[[i]]*=(-1)^Total[weights[[2]]];];
Join[del2valGDvert[#,twovalent],{{newedge,noToWeight[Total[weights]]}}]
]
]
]
]&,GDgraphs[[i]]];
(*Replace all one-edge loops by C[a	0
b	0

] factors*)
prefs[[i]]*=Times@@(c[Transpose[{#,{0,0}}]]&/@(weightToNo/@gdToWeights[GDgraphs[[i]]][[Flatten[Drop[#,-1]&/@Position[GDgraphs[[i]],i_->i_]]]]));
GDgraphs[[i]]=Delete[GDgraphs[[i]],Drop[#,-1]&/@Position[GDgraphs[[i]],i_->i_]];

(*split GD into disconnected components and treat them separately*)
GDgraphs[[i]]=FixedPoint[Function[graph,Block[{result=graph},
discGD=Function[vertlist,Select[graph,FreeQ[#,Alternatives@@vertlist]==False&]]/@(VertexList/@WeaklyConnectedGraphComponents[gdToGraphs[graph]]);
Function[disccomp,
(*Identify dihedral, trihedral and tetrahedral graphs*)
If[VertexCount[gdToGraphs[disccomp]]==2,
If[(Rule@@VertexList[gdToGraphs[disccomp]])=!=#[[1]],prefs[[i]]*=(-1)^Total[weightToNo[#[[2]]]];]&/@disccomp;
prefs[[i]]*=c[Transpose[weightToNo[disccomp[[All,2]]]]];
result=DeleteCases[result,Alternatives@@disccomp];
];
If[VertexCount[gdToGraphs[disccomp]]==3&&VertexConnectivity[gdToGraphs[disccomp]/.Rule->UndirectedEdge]>1,
If[!MatchQ[#[[1]],Alternatives@@((Rule@@VertexList[gdToGraphs[disccomp]][[#]])&/@{{1,2},{2,3},{3,1}})],prefs[[i]]*=(-1)^Total[weightToNo[#[[2]]]];]&/@disccomp;
prefs[[i]]*=c@@(Transpose/@(weightToNo[disccomp[[All,2]][[#[[1]]]]&/@Position[disccomp,Alternatives@@((Rule@@VertexList[gdToGraphs[disccomp]][[#]])&/@#)]]&/@({#,Reverse[#]}&/@{{1,2},{2,3},{3,1}})));
result=DeleteCases[result,Alternatives@@disccomp];
];
If[VertexCount[gdToGraphs[disccomp]]==4&&VertexConnectivity[gdToGraphs[disccomp]/.Rule->UndirectedEdge]>1,
If[!MatchQ[#[[1]],Alternatives@@((Rule@@VertexList[gdToGraphs[disccomp]][[#]])&/@{{1,2},{4,2},{3,2},{4,3},{3,1},{1,4}})],prefs[[i]]*=(-1)^Total[weightToNo[#[[2]]]];]&/@disccomp;
prefs[[i]]*=c@@(Transpose/@(weightToNo[disccomp[[All,2]][[#[[1]]]]&/@Position[disccomp,Alternatives@@((Rule@@VertexList[gdToGraphs[disccomp]][[#]])&/@#)]]&/@({#,Reverse[#]}&/@{{1,2},{4,2},{3,2},{4,3},{3,1},{1,4}})));
result=DeleteCases[result,Alternatives@@disccomp];
];
(*Factorize graphs that are linked by just one vertex*)
If[VertexConnectivity[gdToGraphs[disccomp]/.Rule->UndirectedEdge]==1 &&VertexCount[gdToGraphs[disccomp]]>2,
Block[{undirGraph=gdToGraphs[disccomp]/.Rule->UndirectedEdge,gluingVert,maxVert},
gluingVert=FindVertexCut[undirGraph]/.List->Identity;
maxVert=Max[VertexList[gdToGraphs[result]]];
MapIndexed[result=result/.{(i_->gluingVert)/;MemberQ[#1,i]:>(i->maxVert+(#2/.List->Identity)),(gluingVert->i_)/;MemberQ[#1,i]:>(maxVert+(#2/.List->Identity)->i)};&,
VertexList/@ConnectedGraphComponents[VertexDelete[undirGraph,gluingVert]]];
];];
]/@discGD;
result
]],
GDgraphs[[i]]],
{i,1,Length[GDgraphs]}];
Return[{tetLimCSimplify/@(triLimCSimplify/@(diLimCSimplify/@prefs)),GDgraphs}]];


gList[points_]:=Subsets[Range[points],{2}];

gsList::usage="Expects the number of punctures in the Koba-Nielsen factor and the order to which to expand it and returns a list of lists of point pairs for each term in the expansion.";
gsList[points_,order_]:=Flatten[Outer@@Join[{List},If[order==0,{{}},ConstantArray[If[Head[points]===List,points,gList[points]],order]],{1}],If[order>0,order-1,order]];


gdG::usage="Graph-data list for a Green function.";
gdG[i_,j_]:={{tau[2]/\[Pi]},{{{i->j,"(1,1)"}}}};


zIntegrate[GDarg_,glist_,order_]:=Block[{GD},
If[GDarg===0||order<0,Return[0],
GD=gdFromfn[GDarg];
If[order==0,displayGD[simplifyGD[GD]],
1/order! (Plus@@(Times@@(s@@@#)displayGD[simplifyGD[Fold[cmbGD][Join[{GD},gdG@@@#]]]]&/@gsList[glist,order]))]
]
];


Print["Successfully loaded the ModularGraphForms package. Have fun!"];


End[]


EndPackage[]
Protect["ModularGraphForms`*"];
